{"ast":null,"code":"import PropTypes from 'prop-types';\nimport { Component, cloneElement, useRef, useEffect, useCallback, useLayoutEffect, useReducer, useMemo } from 'react';\nimport { isForwardRef } from 'react-is';\nimport computeScrollIntoView from 'compute-scroll-into-view';\nimport { __assign } from 'tslib';\nlet idCounter = 0;\n/**\n * Accepts a parameter and returns it if it's a function\n * or a noop function if it's not. This allows us to\n * accept a callback, but not worry about it if it's not\n * passed.\n * @param {Function} cb the callback\n * @return {Function} a function\n */\n\nfunction cbToCb(cb) {\n  return typeof cb === 'function' ? cb : noop;\n}\n\nfunction noop() {}\n/**\n * Scroll node into view if necessary\n * @param {HTMLElement} node the element that should scroll into view\n * @param {HTMLElement} menuNode the menu element of the component\n */\n\n\nfunction scrollIntoView(node, menuNode) {\n  if (!node) {\n    return;\n  }\n\n  const actions = computeScrollIntoView(node, {\n    boundary: menuNode,\n    block: 'nearest',\n    scrollMode: 'if-needed'\n  });\n  actions.forEach(_ref => {\n    let {\n      el,\n      top,\n      left\n    } = _ref;\n    el.scrollTop = top;\n    el.scrollLeft = left;\n  });\n}\n/**\n * @param {HTMLElement} parent the parent node\n * @param {HTMLElement} child the child node\n * @param {Window} environment The window context where downshift renders.\n * @return {Boolean} whether the parent is the child or the child is in the parent\n */\n\n\nfunction isOrContainsNode(parent, child, environment) {\n  const result = parent === child || child instanceof environment.Node && parent.contains && parent.contains(child);\n  return result;\n}\n/**\n * Simple debounce implementation. Will call the given\n * function once after the time given has passed since\n * it was last called.\n * @param {Function} fn the function to call after the time\n * @param {Number} time the time to wait\n * @return {Function} the debounced function\n */\n\n\nfunction debounce(fn, time) {\n  let timeoutId;\n\n  function cancel() {\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n    }\n  }\n\n  function wrapper() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    cancel();\n    timeoutId = setTimeout(() => {\n      timeoutId = null;\n      fn(...args);\n    }, time);\n  }\n\n  wrapper.cancel = cancel;\n  return wrapper;\n}\n/**\n * This is intended to be used to compose event handlers.\n * They are executed in order until one of them sets\n * `event.preventDownshiftDefault = true`.\n * @param {...Function} fns the event handler functions\n * @return {Function} the event handler to add to an element\n */\n\n\nfunction callAllEventHandlers() {\n  for (var _len2 = arguments.length, fns = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    fns[_key2] = arguments[_key2];\n  }\n\n  return function (event) {\n    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n      args[_key3 - 1] = arguments[_key3];\n    }\n\n    return fns.some(fn => {\n      if (fn) {\n        fn(event, ...args);\n      }\n\n      return event.preventDownshiftDefault || event.hasOwnProperty('nativeEvent') && event.nativeEvent.preventDownshiftDefault;\n    });\n  };\n}\n\nfunction handleRefs() {\n  for (var _len4 = arguments.length, refs = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n    refs[_key4] = arguments[_key4];\n  }\n\n  return node => {\n    refs.forEach(ref => {\n      if (typeof ref === 'function') {\n        ref(node);\n      } else if (ref) {\n        ref.current = node;\n      }\n    });\n  };\n}\n/**\n * This generates a unique ID for an instance of Downshift\n * @return {String} the unique ID\n */\n\n\nfunction generateId() {\n  return String(idCounter++);\n}\n/**\n * Resets idCounter to 0. Used for SSR.\n */\n\n\nfunction resetIdCounter() {\n  idCounter = 0;\n}\n/**\n * Default implementation for status message. Only added when menu is open.\n * Will specify if there are results in the list, and if so, how many,\n * and what keys are relevant.\n *\n * @param {Object} param the downshift state and other relevant properties\n * @return {String} the a11y status message\n */\n\n\nfunction getA11yStatusMessage$1(_ref2) {\n  let {\n    isOpen,\n    resultCount,\n    previousResultCount\n  } = _ref2;\n\n  if (!isOpen) {\n    return '';\n  }\n\n  if (!resultCount) {\n    return 'No results are available.';\n  }\n\n  if (resultCount !== previousResultCount) {\n    return `${resultCount} result${resultCount === 1 ? ' is' : 's are'} available, use up and down arrow keys to navigate. Press Enter key to select.`;\n  }\n\n  return '';\n}\n/**\n * Takes an argument and if it's an array, returns the first item in the array\n * otherwise returns the argument\n * @param {*} arg the maybe-array\n * @param {*} defaultValue the value if arg is falsey not defined\n * @return {*} the arg or it's first item\n */\n\n\nfunction unwrapArray(arg, defaultValue) {\n  arg = Array.isArray(arg) ?\n  /* istanbul ignore next (preact) */\n  arg[0] : arg;\n\n  if (!arg && defaultValue) {\n    return defaultValue;\n  } else {\n    return arg;\n  }\n}\n/**\n * @param {Object} element (P)react element\n * @return {Boolean} whether it's a DOM element\n */\n\n\nfunction isDOMElement(element) {\n  return typeof element.type === 'string';\n}\n/**\n * @param {Object} element (P)react element\n * @return {Object} the props\n */\n\n\nfunction getElementProps(element) {\n  return element.props;\n}\n/**\n * Throws a helpful error message for required properties. Useful\n * to be used as a default in destructuring or object params.\n * @param {String} fnName the function name\n * @param {String} propName the prop name\n */\n\n\nfunction requiredProp(fnName, propName) {\n  // eslint-disable-next-line no-console\n  console.error(`The property \"${propName}\" is required in \"${fnName}\"`);\n}\n\nconst stateKeys = ['highlightedIndex', 'inputValue', 'isOpen', 'selectedItem', 'type'];\n/**\n * @param {Object} state the state object\n * @return {Object} state that is relevant to downshift\n */\n\nfunction pickState(state) {\n  if (state === void 0) {\n    state = {};\n  }\n\n  const result = {};\n  stateKeys.forEach(k => {\n    if (state.hasOwnProperty(k)) {\n      result[k] = state[k];\n    }\n  });\n  return result;\n}\n/**\n * This will perform a shallow merge of the given state object\n * with the state coming from props\n * (for the controlled component scenario)\n * This is used in state updater functions so they're referencing\n * the right state regardless of where it comes from.\n *\n * @param {Object} state The state of the component/hook.\n * @param {Object} props The props that may contain controlled values.\n * @returns {Object} The merged controlled state.\n */\n\n\nfunction getState(state, props) {\n  return Object.keys(state).reduce((prevState, key) => {\n    prevState[key] = isControlledProp(props, key) ? props[key] : state[key];\n    return prevState;\n  }, {});\n}\n/**\n * This determines whether a prop is a \"controlled prop\" meaning it is\n * state which is controlled by the outside of this component rather\n * than within this component.\n *\n * @param {Object} props The props that may contain controlled values.\n * @param {String} key the key to check\n * @return {Boolean} whether it is a controlled controlled prop\n */\n\n\nfunction isControlledProp(props, key) {\n  return props[key] !== undefined;\n}\n/**\n * Normalizes the 'key' property of a KeyboardEvent in IE/Edge\n * @param {Object} event a keyboardEvent object\n * @return {String} keyboard key\n */\n\n\nfunction normalizeArrowKey(event) {\n  const {\n    key,\n    keyCode\n  } = event;\n  /* istanbul ignore next (ie) */\n\n  if (keyCode >= 37 && keyCode <= 40 && key.indexOf('Arrow') !== 0) {\n    return `Arrow${key}`;\n  }\n\n  return key;\n}\n/**\n * Simple check if the value passed is object literal\n * @param {*} obj any things\n * @return {Boolean} whether it's object literal\n */\n\n\nfunction isPlainObject(obj) {\n  return Object.prototype.toString.call(obj) === '[object Object]';\n}\n/**\n * Returns the new index in the list, in a circular way. If next value is out of bonds from the total,\n * it will wrap to either 0 or itemCount - 1.\n *\n * @param {number} moveAmount Number of positions to move. Negative to move backwards, positive forwards.\n * @param {number} baseIndex The initial position to move from.\n * @param {number} itemCount The total number of items.\n * @param {Function} getItemNodeFromIndex Used to check if item is disabled.\n * @param {boolean} circular Specify if navigation is circular. Default is true.\n * @returns {number} The new index after the move.\n */\n\n\nfunction getNextWrappingIndex(moveAmount, baseIndex, itemCount, getItemNodeFromIndex, circular) {\n  if (circular === void 0) {\n    circular = true;\n  }\n\n  if (itemCount === 0) {\n    return -1;\n  }\n\n  const itemsLastIndex = itemCount - 1;\n\n  if (typeof baseIndex !== 'number' || baseIndex < 0 || baseIndex >= itemCount) {\n    baseIndex = moveAmount > 0 ? -1 : itemsLastIndex + 1;\n  }\n\n  let newIndex = baseIndex + moveAmount;\n\n  if (newIndex < 0) {\n    newIndex = circular ? itemsLastIndex : 0;\n  } else if (newIndex > itemsLastIndex) {\n    newIndex = circular ? 0 : itemsLastIndex;\n  }\n\n  const nonDisabledNewIndex = getNextNonDisabledIndex(moveAmount, newIndex, itemCount, getItemNodeFromIndex, circular);\n\n  if (nonDisabledNewIndex === -1) {\n    return baseIndex >= itemCount ? -1 : baseIndex;\n  }\n\n  return nonDisabledNewIndex;\n}\n/**\n * Returns the next index in the list of an item that is not disabled.\n *\n * @param {number} moveAmount Number of positions to move. Negative to move backwards, positive forwards.\n * @param {number} baseIndex The initial position to move from.\n * @param {number} itemCount The total number of items.\n * @param {Function} getItemNodeFromIndex Used to check if item is disabled.\n * @param {boolean} circular Specify if navigation is circular. Default is true.\n * @returns {number} The new index. Returns baseIndex if item is not disabled. Returns next non-disabled item otherwise. If no non-disabled found it will return -1.\n */\n\n\nfunction getNextNonDisabledIndex(moveAmount, baseIndex, itemCount, getItemNodeFromIndex, circular) {\n  const currentElementNode = getItemNodeFromIndex(baseIndex);\n\n  if (!currentElementNode || !currentElementNode.hasAttribute('disabled')) {\n    return baseIndex;\n  }\n\n  if (moveAmount > 0) {\n    for (let index = baseIndex + 1; index < itemCount; index++) {\n      if (!getItemNodeFromIndex(index).hasAttribute('disabled')) {\n        return index;\n      }\n    }\n  } else {\n    for (let index = baseIndex - 1; index >= 0; index--) {\n      if (!getItemNodeFromIndex(index).hasAttribute('disabled')) {\n        return index;\n      }\n    }\n  }\n\n  if (circular) {\n    return moveAmount > 0 ? getNextNonDisabledIndex(1, 0, itemCount, getItemNodeFromIndex, false) : getNextNonDisabledIndex(-1, itemCount - 1, itemCount, getItemNodeFromIndex, false);\n  }\n\n  return -1;\n}\n/**\n * Checks if event target is within the downshift elements.\n *\n * @param {EventTarget} target Target to check.\n * @param {HTMLElement[]} downshiftElements The elements that form downshift (list, toggle button etc).\n * @param {Window} environment The window context where downshift renders.\n * @param {boolean} checkActiveElement Whether to also check activeElement.\n *\n * @returns {boolean} Whether or not the target is within downshift elements.\n */\n\n\nfunction targetWithinDownshift(target, downshiftElements, environment, checkActiveElement) {\n  if (checkActiveElement === void 0) {\n    checkActiveElement = true;\n  }\n\n  return downshiftElements.some(contextNode => contextNode && (isOrContainsNode(contextNode, target, environment) || checkActiveElement && isOrContainsNode(contextNode, environment.document.activeElement, environment)));\n} // eslint-disable-next-line import/no-mutable-exports\n\n\nlet validateControlledUnchanged = noop;\n/* istanbul ignore next */\n\nif (process.env.NODE_ENV !== 'production') {\n  validateControlledUnchanged = (state, prevProps, nextProps) => {\n    const warningDescription = `This prop should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled Downshift element for the lifetime of the component. More info: https://github.com/downshift-js/downshift#control-props`;\n    Object.keys(state).forEach(propKey => {\n      if (prevProps[propKey] !== undefined && nextProps[propKey] === undefined) {\n        // eslint-disable-next-line no-console\n        console.error(`downshift: A component has changed the controlled prop \"${propKey}\" to be uncontrolled. ${warningDescription}`);\n      } else if (prevProps[propKey] === undefined && nextProps[propKey] !== undefined) {\n        // eslint-disable-next-line no-console\n        console.error(`downshift: A component has changed the uncontrolled prop \"${propKey}\" to be controlled. ${warningDescription}`);\n      }\n    });\n  };\n}\n\nconst cleanupStatus = debounce(documentProp => {\n  getStatusDiv(documentProp).textContent = '';\n}, 500);\n/**\n * @param {String} status the status message\n * @param {Object} documentProp document passed by the user.\n */\n\nfunction setStatus(status, documentProp) {\n  const div = getStatusDiv(documentProp);\n\n  if (!status) {\n    return;\n  }\n\n  div.textContent = status;\n  cleanupStatus(documentProp);\n}\n/**\n * Get the status node or create it if it does not already exist.\n * @param {Object} documentProp document passed by the user.\n * @return {HTMLElement} the status node.\n */\n\n\nfunction getStatusDiv(documentProp) {\n  if (documentProp === void 0) {\n    documentProp = document;\n  }\n\n  let statusDiv = documentProp.getElementById('a11y-status-message');\n\n  if (statusDiv) {\n    return statusDiv;\n  }\n\n  statusDiv = documentProp.createElement('div');\n  statusDiv.setAttribute('id', 'a11y-status-message');\n  statusDiv.setAttribute('role', 'status');\n  statusDiv.setAttribute('aria-live', 'polite');\n  statusDiv.setAttribute('aria-relevant', 'additions text');\n  Object.assign(statusDiv.style, {\n    border: '0',\n    clip: 'rect(0 0 0 0)',\n    height: '1px',\n    margin: '-1px',\n    overflow: 'hidden',\n    padding: '0',\n    position: 'absolute',\n    width: '1px'\n  });\n  documentProp.body.appendChild(statusDiv);\n  return statusDiv;\n}\n\nconst unknown = process.env.NODE_ENV !== \"production\" ? '__autocomplete_unknown__' : 0;\nconst mouseUp = process.env.NODE_ENV !== \"production\" ? '__autocomplete_mouseup__' : 1;\nconst itemMouseEnter = process.env.NODE_ENV !== \"production\" ? '__autocomplete_item_mouseenter__' : 2;\nconst keyDownArrowUp = process.env.NODE_ENV !== \"production\" ? '__autocomplete_keydown_arrow_up__' : 3;\nconst keyDownArrowDown = process.env.NODE_ENV !== \"production\" ? '__autocomplete_keydown_arrow_down__' : 4;\nconst keyDownEscape = process.env.NODE_ENV !== \"production\" ? '__autocomplete_keydown_escape__' : 5;\nconst keyDownEnter = process.env.NODE_ENV !== \"production\" ? '__autocomplete_keydown_enter__' : 6;\nconst keyDownHome = process.env.NODE_ENV !== \"production\" ? '__autocomplete_keydown_home__' : 7;\nconst keyDownEnd = process.env.NODE_ENV !== \"production\" ? '__autocomplete_keydown_end__' : 8;\nconst clickItem = process.env.NODE_ENV !== \"production\" ? '__autocomplete_click_item__' : 9;\nconst blurInput = process.env.NODE_ENV !== \"production\" ? '__autocomplete_blur_input__' : 10;\nconst changeInput = process.env.NODE_ENV !== \"production\" ? '__autocomplete_change_input__' : 11;\nconst keyDownSpaceButton = process.env.NODE_ENV !== \"production\" ? '__autocomplete_keydown_space_button__' : 12;\nconst clickButton = process.env.NODE_ENV !== \"production\" ? '__autocomplete_click_button__' : 13;\nconst blurButton = process.env.NODE_ENV !== \"production\" ? '__autocomplete_blur_button__' : 14;\nconst controlledPropUpdatedSelectedItem = process.env.NODE_ENV !== \"production\" ? '__autocomplete_controlled_prop_updated_selected_item__' : 15;\nconst touchEnd = process.env.NODE_ENV !== \"production\" ? '__autocomplete_touchend__' : 16;\nvar stateChangeTypes$3 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  unknown: unknown,\n  mouseUp: mouseUp,\n  itemMouseEnter: itemMouseEnter,\n  keyDownArrowUp: keyDownArrowUp,\n  keyDownArrowDown: keyDownArrowDown,\n  keyDownEscape: keyDownEscape,\n  keyDownEnter: keyDownEnter,\n  keyDownHome: keyDownHome,\n  keyDownEnd: keyDownEnd,\n  clickItem: clickItem,\n  blurInput: blurInput,\n  changeInput: changeInput,\n  keyDownSpaceButton: keyDownSpaceButton,\n  clickButton: clickButton,\n  blurButton: blurButton,\n  controlledPropUpdatedSelectedItem: controlledPropUpdatedSelectedItem,\n  touchEnd: touchEnd\n});\n/* eslint camelcase:0 */\n\nconst Downshift = /*#__PURE__*/(() => {\n  class Downshift extends Component {\n    constructor(_props) {\n      var _this;\n\n      super(_props);\n      _this = this;\n      this.id = this.props.id || `downshift-${generateId()}`;\n      this.menuId = this.props.menuId || `${this.id}-menu`;\n      this.labelId = this.props.labelId || `${this.id}-label`;\n      this.inputId = this.props.inputId || `${this.id}-input`;\n\n      this.getItemId = this.props.getItemId || (index => `${this.id}-item-${index}`);\n\n      this.input = null;\n      this.items = [];\n      this.itemCount = null;\n      this.previousResultCount = 0;\n      this.timeoutIds = [];\n\n      this.internalSetTimeout = (fn, time) => {\n        const id = setTimeout(() => {\n          this.timeoutIds = this.timeoutIds.filter(i => i !== id);\n          fn();\n        }, time);\n        this.timeoutIds.push(id);\n      };\n\n      this.setItemCount = count => {\n        this.itemCount = count;\n      };\n\n      this.unsetItemCount = () => {\n        this.itemCount = null;\n      };\n\n      this.setHighlightedIndex = function (highlightedIndex, otherStateToSet) {\n        if (highlightedIndex === void 0) {\n          highlightedIndex = _this.props.defaultHighlightedIndex;\n        }\n\n        if (otherStateToSet === void 0) {\n          otherStateToSet = {};\n        }\n\n        otherStateToSet = pickState(otherStateToSet);\n\n        _this.internalSetState({\n          highlightedIndex,\n          ...otherStateToSet\n        });\n      };\n\n      this.clearSelection = cb => {\n        this.internalSetState({\n          selectedItem: null,\n          inputValue: '',\n          highlightedIndex: this.props.defaultHighlightedIndex,\n          isOpen: this.props.defaultIsOpen\n        }, cb);\n      };\n\n      this.selectItem = (item, otherStateToSet, cb) => {\n        otherStateToSet = pickState(otherStateToSet);\n        this.internalSetState({\n          isOpen: this.props.defaultIsOpen,\n          highlightedIndex: this.props.defaultHighlightedIndex,\n          selectedItem: item,\n          inputValue: this.props.itemToString(item),\n          ...otherStateToSet\n        }, cb);\n      };\n\n      this.selectItemAtIndex = (itemIndex, otherStateToSet, cb) => {\n        const item = this.items[itemIndex];\n\n        if (item == null) {\n          return;\n        }\n\n        this.selectItem(item, otherStateToSet, cb);\n      };\n\n      this.selectHighlightedItem = (otherStateToSet, cb) => {\n        return this.selectItemAtIndex(this.getState().highlightedIndex, otherStateToSet, cb);\n      };\n\n      this.internalSetState = (stateToSet, cb) => {\n        let isItemSelected, onChangeArg;\n        const onStateChangeArg = {};\n        const isStateToSetFunction = typeof stateToSet === 'function'; // we want to call `onInputValueChange` before the `setState` call\n        // so someone controlling the `inputValue` state gets notified of\n        // the input change as soon as possible. This avoids issues with\n        // preserving the cursor position.\n        // See https://github.com/downshift-js/downshift/issues/217 for more info.\n\n        if (!isStateToSetFunction && stateToSet.hasOwnProperty('inputValue')) {\n          this.props.onInputValueChange(stateToSet.inputValue, { ...this.getStateAndHelpers(),\n            ...stateToSet\n          });\n        }\n\n        return this.setState(state => {\n          state = this.getState(state);\n          let newStateToSet = isStateToSetFunction ? stateToSet(state) : stateToSet; // Your own function that could modify the state that will be set.\n\n          newStateToSet = this.props.stateReducer(state, newStateToSet); // checks if an item is selected, regardless of if it's different from\n          // what was selected before\n          // used to determine if onSelect and onChange callbacks should be called\n\n          isItemSelected = newStateToSet.hasOwnProperty('selectedItem'); // this keeps track of the object we want to call with setState\n\n          const nextState = {}; // this is just used to tell whether the state changed\n          // and we're trying to update that state. OR if the selection has changed and we're\n          // trying to update the selection\n\n          if (isItemSelected && newStateToSet.selectedItem !== state.selectedItem) {\n            onChangeArg = newStateToSet.selectedItem;\n          }\n\n          newStateToSet.type = newStateToSet.type || unknown;\n          Object.keys(newStateToSet).forEach(key => {\n            // onStateChangeArg should only have the state that is\n            // actually changing\n            if (state[key] !== newStateToSet[key]) {\n              onStateChangeArg[key] = newStateToSet[key];\n            } // the type is useful for the onStateChangeArg\n            // but we don't actually want to set it in internal state.\n            // this is an undocumented feature for now... Not all internalSetState\n            // calls support it and I'm not certain we want them to yet.\n            // But it enables users controlling the isOpen state to know when\n            // the isOpen state changes due to mouseup events which is quite handy.\n\n\n            if (key === 'type') {\n              return;\n            }\n\n            newStateToSet[key]; // if it's coming from props, then we don't care to set it internally\n\n            if (!isControlledProp(this.props, key)) {\n              nextState[key] = newStateToSet[key];\n            }\n          }); // if stateToSet is a function, then we weren't able to call onInputValueChange\n          // earlier, so we'll call it now that we know what the inputValue state will be.\n\n          if (isStateToSetFunction && newStateToSet.hasOwnProperty('inputValue')) {\n            this.props.onInputValueChange(newStateToSet.inputValue, { ...this.getStateAndHelpers(),\n              ...newStateToSet\n            });\n          }\n\n          return nextState;\n        }, () => {\n          // call the provided callback if it's a function\n          cbToCb(cb)(); // only call the onStateChange and onChange callbacks if\n          // we have relevant information to pass them.\n\n          const hasMoreStateThanType = Object.keys(onStateChangeArg).length > 1;\n\n          if (hasMoreStateThanType) {\n            this.props.onStateChange(onStateChangeArg, this.getStateAndHelpers());\n          }\n\n          if (isItemSelected) {\n            this.props.onSelect(stateToSet.selectedItem, this.getStateAndHelpers());\n          }\n\n          if (onChangeArg !== undefined) {\n            this.props.onChange(onChangeArg, this.getStateAndHelpers());\n          } // this is currently undocumented and therefore subject to change\n          // We'll try to not break it, but just be warned.\n\n\n          this.props.onUserAction(onStateChangeArg, this.getStateAndHelpers());\n        });\n      };\n\n      this.rootRef = node => this._rootNode = node;\n\n      this.getRootProps = function (_temp, _temp2) {\n        let {\n          refKey = 'ref',\n          ref,\n          ...rest\n        } = _temp === void 0 ? {} : _temp;\n        let {\n          suppressRefError = false\n        } = _temp2 === void 0 ? {} : _temp2; // this is used in the render to know whether the user has called getRootProps.\n        // It uses that to know whether to apply the props automatically\n\n        _this.getRootProps.called = true;\n        _this.getRootProps.refKey = refKey;\n        _this.getRootProps.suppressRefError = suppressRefError;\n\n        const {\n          isOpen\n        } = _this.getState();\n\n        return {\n          [refKey]: handleRefs(ref, _this.rootRef),\n          role: 'combobox',\n          'aria-expanded': isOpen,\n          'aria-haspopup': 'listbox',\n          'aria-owns': isOpen ? _this.menuId : null,\n          'aria-labelledby': _this.labelId,\n          ...rest\n        };\n      };\n\n      this.keyDownHandlers = {\n        ArrowDown(event) {\n          event.preventDefault();\n\n          if (this.getState().isOpen) {\n            const amount = event.shiftKey ? 5 : 1;\n            this.moveHighlightedIndex(amount, {\n              type: keyDownArrowDown\n            });\n          } else {\n            this.internalSetState({\n              isOpen: true,\n              type: keyDownArrowDown\n            }, () => {\n              const itemCount = this.getItemCount();\n\n              if (itemCount > 0) {\n                const {\n                  highlightedIndex\n                } = this.getState();\n                const nextHighlightedIndex = getNextWrappingIndex(1, highlightedIndex, itemCount, index => this.getItemNodeFromIndex(index));\n                this.setHighlightedIndex(nextHighlightedIndex, {\n                  type: keyDownArrowDown\n                });\n              }\n            });\n          }\n        },\n\n        ArrowUp(event) {\n          event.preventDefault();\n\n          if (this.getState().isOpen) {\n            const amount = event.shiftKey ? -5 : -1;\n            this.moveHighlightedIndex(amount, {\n              type: keyDownArrowUp\n            });\n          } else {\n            this.internalSetState({\n              isOpen: true,\n              type: keyDownArrowUp\n            }, () => {\n              const itemCount = this.getItemCount();\n\n              if (itemCount > 0) {\n                const {\n                  highlightedIndex\n                } = this.getState();\n                const nextHighlightedIndex = getNextWrappingIndex(-1, highlightedIndex, itemCount, index => this.getItemNodeFromIndex(index));\n                this.setHighlightedIndex(nextHighlightedIndex, {\n                  type: keyDownArrowUp\n                });\n              }\n            });\n          }\n        },\n\n        Enter(event) {\n          if (event.which === 229) {\n            return;\n          }\n\n          const {\n            isOpen,\n            highlightedIndex\n          } = this.getState();\n\n          if (isOpen && highlightedIndex != null) {\n            event.preventDefault();\n            const item = this.items[highlightedIndex];\n            const itemNode = this.getItemNodeFromIndex(highlightedIndex);\n\n            if (item == null || itemNode && itemNode.hasAttribute('disabled')) {\n              return;\n            }\n\n            this.selectHighlightedItem({\n              type: keyDownEnter\n            });\n          }\n        },\n\n        Escape(event) {\n          event.preventDefault();\n          this.reset({\n            type: keyDownEscape,\n            ...(!this.state.isOpen && {\n              selectedItem: null,\n              inputValue: ''\n            })\n          });\n        }\n\n      };\n      this.buttonKeyDownHandlers = { ...this.keyDownHandlers,\n\n        ' '(event) {\n          event.preventDefault();\n          this.toggleMenu({\n            type: keyDownSpaceButton\n          });\n        }\n\n      };\n      this.inputKeyDownHandlers = { ...this.keyDownHandlers,\n\n        Home(event) {\n          const {\n            isOpen\n          } = this.getState();\n\n          if (!isOpen) {\n            return;\n          }\n\n          event.preventDefault();\n          const itemCount = this.getItemCount();\n\n          if (itemCount <= 0 || !isOpen) {\n            return;\n          } // get next non-disabled starting downwards from 0 if that's disabled.\n\n\n          const newHighlightedIndex = getNextNonDisabledIndex(1, 0, itemCount, index => this.getItemNodeFromIndex(index), false);\n          this.setHighlightedIndex(newHighlightedIndex, {\n            type: keyDownHome\n          });\n        },\n\n        End(event) {\n          const {\n            isOpen\n          } = this.getState();\n\n          if (!isOpen) {\n            return;\n          }\n\n          event.preventDefault();\n          const itemCount = this.getItemCount();\n\n          if (itemCount <= 0 || !isOpen) {\n            return;\n          } // get next non-disabled starting upwards from last index if that's disabled.\n\n\n          const newHighlightedIndex = getNextNonDisabledIndex(-1, itemCount - 1, itemCount, index => this.getItemNodeFromIndex(index), false);\n          this.setHighlightedIndex(newHighlightedIndex, {\n            type: keyDownEnd\n          });\n        }\n\n      };\n\n      this.getToggleButtonProps = function (_temp3) {\n        let {\n          onClick,\n          onPress,\n          onKeyDown,\n          onKeyUp,\n          onBlur,\n          ...rest\n        } = _temp3 === void 0 ? {} : _temp3;\n\n        const {\n          isOpen\n        } = _this.getState();\n\n        const enabledEventHandlers = {\n          onClick: callAllEventHandlers(onClick, _this.buttonHandleClick),\n          onKeyDown: callAllEventHandlers(onKeyDown, _this.buttonHandleKeyDown),\n          onKeyUp: callAllEventHandlers(onKeyUp, _this.buttonHandleKeyUp),\n          onBlur: callAllEventHandlers(onBlur, _this.buttonHandleBlur)\n        };\n        const eventHandlers = rest.disabled ? {} : enabledEventHandlers;\n        return {\n          type: 'button',\n          role: 'button',\n          'aria-label': isOpen ? 'close menu' : 'open menu',\n          'aria-haspopup': true,\n          'data-toggle': true,\n          ...eventHandlers,\n          ...rest\n        };\n      };\n\n      this.buttonHandleKeyUp = event => {\n        // Prevent click event from emitting in Firefox\n        event.preventDefault();\n      };\n\n      this.buttonHandleKeyDown = event => {\n        const key = normalizeArrowKey(event);\n\n        if (this.buttonKeyDownHandlers[key]) {\n          this.buttonKeyDownHandlers[key].call(this, event);\n        }\n      };\n\n      this.buttonHandleClick = event => {\n        event.preventDefault(); // handle odd case for Safari and Firefox which\n        // don't give the button the focus properly.\n\n        /* istanbul ignore if (can't reasonably test this) */\n\n        if (this.props.environment.document.activeElement === this.props.environment.document.body) {\n          event.target.focus();\n        } // to simplify testing components that use downshift, we'll not wrap this in a setTimeout\n        // if the NODE_ENV is test. With the proper build system, this should be dead code eliminated\n        // when building for production and should therefore have no impact on production code.\n\n\n        if (process.env.NODE_ENV === 'test') {\n          this.toggleMenu({\n            type: clickButton\n          });\n        } else {\n          // Ensure that toggle of menu occurs after the potential blur event in iOS\n          this.internalSetTimeout(() => this.toggleMenu({\n            type: clickButton\n          }));\n        }\n      };\n\n      this.buttonHandleBlur = event => {\n        const blurTarget = event.target; // Save blur target for comparison with activeElement later\n        // Need setTimeout, so that when the user presses Tab, the activeElement is the next focused element, not body element\n\n        this.internalSetTimeout(() => {\n          if (!this.isMouseDown && (this.props.environment.document.activeElement == null || this.props.environment.document.activeElement.id !== this.inputId) && this.props.environment.document.activeElement !== blurTarget // Do nothing if we refocus the same element again (to solve issue in Safari on iOS)\n          ) {\n            this.reset({\n              type: blurButton\n            });\n          }\n        });\n      };\n\n      this.getLabelProps = props => {\n        return {\n          htmlFor: this.inputId,\n          id: this.labelId,\n          ...props\n        };\n      };\n\n      this.getInputProps = function (_temp4) {\n        let {\n          onKeyDown,\n          onBlur,\n          onChange,\n          onInput,\n          onChangeText,\n          ...rest\n        } = _temp4 === void 0 ? {} : _temp4;\n        let onChangeKey;\n        let eventHandlers = {};\n        /* istanbul ignore next (preact) */\n\n        {\n          onChangeKey = 'onChange';\n        }\n\n        const {\n          inputValue,\n          isOpen,\n          highlightedIndex\n        } = _this.getState();\n\n        if (!rest.disabled) {\n          eventHandlers = {\n            [onChangeKey]: callAllEventHandlers(onChange, onInput, _this.inputHandleChange),\n            onKeyDown: callAllEventHandlers(onKeyDown, _this.inputHandleKeyDown),\n            onBlur: callAllEventHandlers(onBlur, _this.inputHandleBlur)\n          };\n        }\n\n        return {\n          'aria-autocomplete': 'list',\n          'aria-activedescendant': isOpen && typeof highlightedIndex === 'number' && highlightedIndex >= 0 ? _this.getItemId(highlightedIndex) : null,\n          'aria-controls': isOpen ? _this.menuId : null,\n          'aria-labelledby': _this.labelId,\n          // https://developer.mozilla.org/en-US/docs/Web/Security/Securing_your_site/Turning_off_form_autocompletion\n          // revert back since autocomplete=\"nope\" is ignored on latest Chrome and Opera\n          autoComplete: 'off',\n          value: inputValue,\n          id: _this.inputId,\n          ...eventHandlers,\n          ...rest\n        };\n      };\n\n      this.inputHandleKeyDown = event => {\n        const key = normalizeArrowKey(event);\n\n        if (key && this.inputKeyDownHandlers[key]) {\n          this.inputKeyDownHandlers[key].call(this, event);\n        }\n      };\n\n      this.inputHandleChange = event => {\n        this.internalSetState({\n          type: changeInput,\n          isOpen: true,\n          inputValue: event.target.value,\n          highlightedIndex: this.props.defaultHighlightedIndex\n        });\n      };\n\n      this.inputHandleBlur = () => {\n        // Need setTimeout, so that when the user presses Tab, the activeElement is the next focused element, not the body element\n        this.internalSetTimeout(() => {\n          const downshiftButtonIsActive = this.props.environment.document && !!this.props.environment.document.activeElement && !!this.props.environment.document.activeElement.dataset && this.props.environment.document.activeElement.dataset.toggle && this._rootNode && this._rootNode.contains(this.props.environment.document.activeElement);\n\n          if (!this.isMouseDown && !downshiftButtonIsActive) {\n            this.reset({\n              type: blurInput\n            });\n          }\n        });\n      };\n\n      this.menuRef = node => {\n        this._menuNode = node;\n      };\n\n      this.getMenuProps = function (_temp5, _temp6) {\n        let {\n          refKey = 'ref',\n          ref,\n          ...props\n        } = _temp5 === void 0 ? {} : _temp5;\n        let {\n          suppressRefError = false\n        } = _temp6 === void 0 ? {} : _temp6;\n        _this.getMenuProps.called = true;\n        _this.getMenuProps.refKey = refKey;\n        _this.getMenuProps.suppressRefError = suppressRefError;\n        return {\n          [refKey]: handleRefs(ref, _this.menuRef),\n          role: 'listbox',\n          'aria-labelledby': props && props['aria-label'] ? null : _this.labelId,\n          id: _this.menuId,\n          ...props\n        };\n      };\n\n      this.getItemProps = function (_temp7) {\n        let {\n          onMouseMove,\n          onMouseDown,\n          onClick,\n          onPress,\n          index,\n          item = process.env.NODE_ENV === 'production' ?\n          /* istanbul ignore next */\n          undefined : requiredProp('getItemProps', 'item'),\n          ...rest\n        } = _temp7 === void 0 ? {} : _temp7;\n\n        if (index === undefined) {\n          _this.items.push(item);\n\n          index = _this.items.indexOf(item);\n        } else {\n          _this.items[index] = item;\n        }\n\n        const onSelectKey = 'onClick';\n        const customClickHandler = onClick;\n        const enabledEventHandlers = {\n          // onMouseMove is used over onMouseEnter here. onMouseMove\n          // is only triggered on actual mouse movement while onMouseEnter\n          // can fire on DOM changes, interrupting keyboard navigation\n          onMouseMove: callAllEventHandlers(onMouseMove, () => {\n            if (index === _this.getState().highlightedIndex) {\n              return;\n            }\n\n            _this.setHighlightedIndex(index, {\n              type: itemMouseEnter\n            }); // We never want to manually scroll when changing state based\n            // on `onMouseMove` because we will be moving the element out\n            // from under the user which is currently scrolling/moving the\n            // cursor\n\n\n            _this.avoidScrolling = true;\n\n            _this.internalSetTimeout(() => _this.avoidScrolling = false, 250);\n          }),\n          onMouseDown: callAllEventHandlers(onMouseDown, event => {\n            // This prevents the activeElement from being changed\n            // to the item so it can remain with the current activeElement\n            // which is a more common use case.\n            event.preventDefault();\n          }),\n          [onSelectKey]: callAllEventHandlers(customClickHandler, () => {\n            _this.selectItemAtIndex(index, {\n              type: clickItem\n            });\n          })\n        }; // Passing down the onMouseDown handler to prevent redirect\n        // of the activeElement if clicking on disabled items\n\n        const eventHandlers = rest.disabled ? {\n          onMouseDown: enabledEventHandlers.onMouseDown\n        } : enabledEventHandlers;\n        return {\n          id: _this.getItemId(index),\n          role: 'option',\n          'aria-selected': _this.getState().highlightedIndex === index,\n          ...eventHandlers,\n          ...rest\n        };\n      };\n\n      this.clearItems = () => {\n        this.items = [];\n      };\n\n      this.reset = function (otherStateToSet, cb) {\n        if (otherStateToSet === void 0) {\n          otherStateToSet = {};\n        }\n\n        otherStateToSet = pickState(otherStateToSet);\n\n        _this.internalSetState(_ref => {\n          let {\n            selectedItem\n          } = _ref;\n          return {\n            isOpen: _this.props.defaultIsOpen,\n            highlightedIndex: _this.props.defaultHighlightedIndex,\n            inputValue: _this.props.itemToString(selectedItem),\n            ...otherStateToSet\n          };\n        }, cb);\n      };\n\n      this.toggleMenu = function (otherStateToSet, cb) {\n        if (otherStateToSet === void 0) {\n          otherStateToSet = {};\n        }\n\n        otherStateToSet = pickState(otherStateToSet);\n\n        _this.internalSetState(_ref2 => {\n          let {\n            isOpen\n          } = _ref2;\n          return {\n            isOpen: !isOpen,\n            ...(isOpen && {\n              highlightedIndex: _this.props.defaultHighlightedIndex\n            }),\n            ...otherStateToSet\n          };\n        }, () => {\n          const {\n            isOpen,\n            highlightedIndex\n          } = _this.getState();\n\n          if (isOpen) {\n            if (_this.getItemCount() > 0 && typeof highlightedIndex === 'number') {\n              _this.setHighlightedIndex(highlightedIndex, otherStateToSet);\n            }\n          }\n\n          cbToCb(cb)();\n        });\n      };\n\n      this.openMenu = cb => {\n        this.internalSetState({\n          isOpen: true\n        }, cb);\n      };\n\n      this.closeMenu = cb => {\n        this.internalSetState({\n          isOpen: false\n        }, cb);\n      };\n\n      this.updateStatus = debounce(() => {\n        const state = this.getState();\n        const item = this.items[state.highlightedIndex];\n        const resultCount = this.getItemCount();\n        const status = this.props.getA11yStatusMessage({\n          itemToString: this.props.itemToString,\n          previousResultCount: this.previousResultCount,\n          resultCount,\n          highlightedItem: item,\n          ...state\n        });\n        this.previousResultCount = resultCount;\n        setStatus(status, this.props.environment.document);\n      }, 200); // fancy destructuring + defaults + aliases\n      // this basically says each value of state should either be set to\n      // the initial value or the default value if the initial value is not provided\n\n      const {\n        defaultHighlightedIndex,\n        initialHighlightedIndex: _highlightedIndex = defaultHighlightedIndex,\n        defaultIsOpen,\n        initialIsOpen: _isOpen = defaultIsOpen,\n        initialInputValue: _inputValue = '',\n        initialSelectedItem: _selectedItem = null\n      } = this.props;\n\n      const _state = this.getState({\n        highlightedIndex: _highlightedIndex,\n        isOpen: _isOpen,\n        inputValue: _inputValue,\n        selectedItem: _selectedItem\n      });\n\n      if (_state.selectedItem != null && this.props.initialInputValue === undefined) {\n        _state.inputValue = this.props.itemToString(_state.selectedItem);\n      }\n\n      this.state = _state;\n    }\n    /**\n     * Clear all running timeouts\n     */\n\n\n    internalClearTimeouts() {\n      this.timeoutIds.forEach(id => {\n        clearTimeout(id);\n      });\n      this.timeoutIds = [];\n    }\n    /**\n     * Gets the state based on internal state or props\n     * If a state value is passed via props, then that\n     * is the value given, otherwise it's retrieved from\n     * stateToMerge\n     *\n     * @param {Object} stateToMerge defaults to this.state\n     * @return {Object} the state\n     */\n\n\n    getState(stateToMerge) {\n      if (stateToMerge === void 0) {\n        stateToMerge = this.state;\n      }\n\n      return getState(stateToMerge, this.props);\n    }\n\n    getItemCount() {\n      // things read better this way. They're in priority order:\n      // 1. `this.itemCount`\n      // 2. `this.props.itemCount`\n      // 3. `this.items.length`\n      let itemCount = this.items.length;\n\n      if (this.itemCount != null) {\n        itemCount = this.itemCount;\n      } else if (this.props.itemCount !== undefined) {\n        itemCount = this.props.itemCount;\n      }\n\n      return itemCount;\n    }\n\n    getItemNodeFromIndex(index) {\n      return this.props.environment.document.getElementById(this.getItemId(index));\n    }\n\n    scrollHighlightedItemIntoView() {\n      /* istanbul ignore else (react-native) */\n      {\n        const node = this.getItemNodeFromIndex(this.getState().highlightedIndex);\n        this.props.scrollIntoView(node, this._menuNode);\n      }\n    }\n\n    moveHighlightedIndex(amount, otherStateToSet) {\n      const itemCount = this.getItemCount();\n      const {\n        highlightedIndex\n      } = this.getState();\n\n      if (itemCount > 0) {\n        const nextHighlightedIndex = getNextWrappingIndex(amount, highlightedIndex, itemCount, index => this.getItemNodeFromIndex(index));\n        this.setHighlightedIndex(nextHighlightedIndex, otherStateToSet);\n      }\n    }\n\n    getStateAndHelpers() {\n      const {\n        highlightedIndex,\n        inputValue,\n        selectedItem,\n        isOpen\n      } = this.getState();\n      const {\n        itemToString\n      } = this.props;\n      const {\n        id\n      } = this;\n      const {\n        getRootProps,\n        getToggleButtonProps,\n        getLabelProps,\n        getMenuProps,\n        getInputProps,\n        getItemProps,\n        openMenu,\n        closeMenu,\n        toggleMenu,\n        selectItem,\n        selectItemAtIndex,\n        selectHighlightedItem,\n        setHighlightedIndex,\n        clearSelection,\n        clearItems,\n        reset,\n        setItemCount,\n        unsetItemCount,\n        internalSetState: setState\n      } = this;\n      return {\n        // prop getters\n        getRootProps,\n        getToggleButtonProps,\n        getLabelProps,\n        getMenuProps,\n        getInputProps,\n        getItemProps,\n        // actions\n        reset,\n        openMenu,\n        closeMenu,\n        toggleMenu,\n        selectItem,\n        selectItemAtIndex,\n        selectHighlightedItem,\n        setHighlightedIndex,\n        clearSelection,\n        clearItems,\n        setItemCount,\n        unsetItemCount,\n        setState,\n        // props\n        itemToString,\n        // derived\n        id,\n        // state\n        highlightedIndex,\n        inputValue,\n        isOpen,\n        selectedItem\n      };\n    } //////////////////////////// ROOT\n\n\n    componentDidMount() {\n      /* istanbul ignore if (react-native) */\n      if (process.env.NODE_ENV !== 'production' && !false && this.getMenuProps.called && !this.getMenuProps.suppressRefError) {\n        validateGetMenuPropsCalledCorrectly(this._menuNode, this.getMenuProps);\n      }\n      /* istanbul ignore if (react-native) */\n\n\n      {\n        // this.isMouseDown helps us track whether the mouse is currently held down.\n        // This is useful when the user clicks on an item in the list, but holds the mouse\n        // down long enough for the list to disappear (because the blur event fires on the input)\n        // this.isMouseDown is used in the blur handler on the input to determine whether the blur event should\n        // trigger hiding the menu.\n        const onMouseDown = () => {\n          this.isMouseDown = true;\n        };\n\n        const onMouseUp = event => {\n          this.isMouseDown = false; // if the target element or the activeElement is within a downshift node\n          // then we don't want to reset downshift\n\n          const contextWithinDownshift = targetWithinDownshift(event.target, [this._rootNode, this._menuNode], this.props.environment);\n\n          if (!contextWithinDownshift && this.getState().isOpen) {\n            this.reset({\n              type: mouseUp\n            }, () => this.props.onOuterClick(this.getStateAndHelpers()));\n          }\n        }; // Touching an element in iOS gives focus and hover states, but touching out of\n        // the element will remove hover, and persist the focus state, resulting in the\n        // blur event not being triggered.\n        // this.isTouchMove helps us track whether the user is tapping or swiping on a touch screen.\n        // If the user taps outside of Downshift, the component should be reset,\n        // but not if the user is swiping\n\n\n        const onTouchStart = () => {\n          this.isTouchMove = false;\n        };\n\n        const onTouchMove = () => {\n          this.isTouchMove = true;\n        };\n\n        const onTouchEnd = event => {\n          const contextWithinDownshift = targetWithinDownshift(event.target, [this._rootNode, this._menuNode], this.props.environment, false);\n\n          if (!this.isTouchMove && !contextWithinDownshift && this.getState().isOpen) {\n            this.reset({\n              type: touchEnd\n            }, () => this.props.onOuterClick(this.getStateAndHelpers()));\n          }\n        };\n\n        const {\n          environment\n        } = this.props;\n        environment.addEventListener('mousedown', onMouseDown);\n        environment.addEventListener('mouseup', onMouseUp);\n        environment.addEventListener('touchstart', onTouchStart);\n        environment.addEventListener('touchmove', onTouchMove);\n        environment.addEventListener('touchend', onTouchEnd);\n\n        this.cleanup = () => {\n          this.internalClearTimeouts();\n          this.updateStatus.cancel();\n          environment.removeEventListener('mousedown', onMouseDown);\n          environment.removeEventListener('mouseup', onMouseUp);\n          environment.removeEventListener('touchstart', onTouchStart);\n          environment.removeEventListener('touchmove', onTouchMove);\n          environment.removeEventListener('touchend', onTouchEnd);\n        };\n      }\n    }\n\n    shouldScroll(prevState, prevProps) {\n      const {\n        highlightedIndex: currentHighlightedIndex\n      } = this.props.highlightedIndex === undefined ? this.getState() : this.props;\n      const {\n        highlightedIndex: prevHighlightedIndex\n      } = prevProps.highlightedIndex === undefined ? prevState : prevProps;\n      const scrollWhenOpen = currentHighlightedIndex && this.getState().isOpen && !prevState.isOpen;\n      const scrollWhenNavigating = currentHighlightedIndex !== prevHighlightedIndex;\n      return scrollWhenOpen || scrollWhenNavigating;\n    }\n\n    componentDidUpdate(prevProps, prevState) {\n      if (process.env.NODE_ENV !== 'production') {\n        validateControlledUnchanged(this.state, prevProps, this.props);\n        /* istanbul ignore if (react-native) */\n\n        if (this.getMenuProps.called && !this.getMenuProps.suppressRefError) {\n          validateGetMenuPropsCalledCorrectly(this._menuNode, this.getMenuProps);\n        }\n      }\n\n      if (isControlledProp(this.props, 'selectedItem') && this.props.selectedItemChanged(prevProps.selectedItem, this.props.selectedItem)) {\n        this.internalSetState({\n          type: controlledPropUpdatedSelectedItem,\n          inputValue: this.props.itemToString(this.props.selectedItem)\n        });\n      }\n\n      if (!this.avoidScrolling && this.shouldScroll(prevState, prevProps)) {\n        this.scrollHighlightedItemIntoView();\n      }\n      /* istanbul ignore else (react-native) */\n\n\n      {\n        this.updateStatus();\n      }\n    }\n\n    componentWillUnmount() {\n      this.cleanup(); // avoids memory leak\n    }\n\n    render() {\n      const children = unwrapArray(this.props.children, noop); // because the items are rerendered every time we call the children\n      // we clear this out each render and it will be populated again as\n      // getItemProps is called.\n\n      this.clearItems(); // we reset this so we know whether the user calls getRootProps during\n      // this render. If they do then we don't need to do anything,\n      // if they don't then we need to clone the element they return and\n      // apply the props for them.\n\n      this.getRootProps.called = false;\n      this.getRootProps.refKey = undefined;\n      this.getRootProps.suppressRefError = undefined; // we do something similar for getMenuProps\n\n      this.getMenuProps.called = false;\n      this.getMenuProps.refKey = undefined;\n      this.getMenuProps.suppressRefError = undefined; // we do something similar for getLabelProps\n\n      this.getLabelProps.called = false; // and something similar for getInputProps\n\n      this.getInputProps.called = false;\n      const element = unwrapArray(children(this.getStateAndHelpers()));\n\n      if (!element) {\n        return null;\n      }\n\n      if (this.getRootProps.called || this.props.suppressRefError) {\n        if (process.env.NODE_ENV !== 'production' && !this.getRootProps.suppressRefError && !this.props.suppressRefError) {\n          validateGetRootPropsCalledCorrectly(element, this.getRootProps);\n        }\n\n        return element;\n      } else if (isDOMElement(element)) {\n        // they didn't apply the root props, but we can clone\n        // this and apply the props ourselves\n        return /*#__PURE__*/cloneElement(element, this.getRootProps(getElementProps(element)));\n      }\n      /* istanbul ignore else */\n\n\n      if (process.env.NODE_ENV !== 'production') {\n        // they didn't apply the root props, but they need to\n        // otherwise we can't query around the autocomplete\n        throw new Error('downshift: If you return a non-DOM element, you must apply the getRootProps function');\n      }\n      /* istanbul ignore next */\n\n\n      return undefined;\n    }\n\n  }\n\n  Downshift.defaultProps = {\n    defaultHighlightedIndex: null,\n    defaultIsOpen: false,\n    getA11yStatusMessage: getA11yStatusMessage$1,\n    itemToString: i => {\n      if (i == null) {\n        return '';\n      }\n\n      if (process.env.NODE_ENV !== 'production' && isPlainObject(i) && !i.hasOwnProperty('toString')) {\n        // eslint-disable-next-line no-console\n        console.warn('downshift: An object was passed to the default implementation of `itemToString`. You should probably provide your own `itemToString` implementation. Please refer to the `itemToString` API documentation.', 'The object that was passed:', i);\n      }\n\n      return String(i);\n    },\n    onStateChange: noop,\n    onInputValueChange: noop,\n    onUserAction: noop,\n    onChange: noop,\n    onSelect: noop,\n    onOuterClick: noop,\n    selectedItemChanged: (prevItem, item) => prevItem !== item,\n    environment:\n    /* istanbul ignore next (ssr) */\n    typeof window === 'undefined' ? {} : window,\n    stateReducer: (state, stateToSet) => stateToSet,\n    suppressRefError: false,\n    scrollIntoView\n  };\n  Downshift.stateChangeTypes = stateChangeTypes$3;\n  return Downshift;\n})();\n\nprocess.env.NODE_ENV !== \"production\" ? Downshift.propTypes = {\n  children: PropTypes.func,\n  defaultHighlightedIndex: PropTypes.number,\n  defaultIsOpen: PropTypes.bool,\n  initialHighlightedIndex: PropTypes.number,\n  initialSelectedItem: PropTypes.any,\n  initialInputValue: PropTypes.string,\n  initialIsOpen: PropTypes.bool,\n  getA11yStatusMessage: PropTypes.func,\n  itemToString: PropTypes.func,\n  onChange: PropTypes.func,\n  onSelect: PropTypes.func,\n  onStateChange: PropTypes.func,\n  onInputValueChange: PropTypes.func,\n  onUserAction: PropTypes.func,\n  onOuterClick: PropTypes.func,\n  selectedItemChanged: PropTypes.func,\n  stateReducer: PropTypes.func,\n  itemCount: PropTypes.number,\n  id: PropTypes.string,\n  environment: PropTypes.shape({\n    addEventListener: PropTypes.func,\n    removeEventListener: PropTypes.func,\n    document: PropTypes.shape({\n      getElementById: PropTypes.func,\n      activeElement: PropTypes.any,\n      body: PropTypes.any\n    })\n  }),\n  suppressRefError: PropTypes.bool,\n  scrollIntoView: PropTypes.func,\n  // things we keep in state for uncontrolled components\n  // but can accept as props for controlled components\n\n  /* eslint-disable react/no-unused-prop-types */\n  selectedItem: PropTypes.any,\n  isOpen: PropTypes.bool,\n  inputValue: PropTypes.string,\n  highlightedIndex: PropTypes.number,\n  labelId: PropTypes.string,\n  inputId: PropTypes.string,\n  menuId: PropTypes.string,\n  getItemId: PropTypes.func\n  /* eslint-enable react/no-unused-prop-types */\n\n} : void 0;\nvar Downshift$1 = Downshift;\n\nfunction validateGetMenuPropsCalledCorrectly(node, _ref3) {\n  let {\n    refKey\n  } = _ref3;\n\n  if (!node) {\n    // eslint-disable-next-line no-console\n    console.error(`downshift: The ref prop \"${refKey}\" from getMenuProps was not applied correctly on your menu element.`);\n  }\n}\n\nfunction validateGetRootPropsCalledCorrectly(element, _ref4) {\n  let {\n    refKey\n  } = _ref4;\n  const refKeySpecified = refKey !== 'ref';\n  const isComposite = !isDOMElement(element);\n\n  if (isComposite && !refKeySpecified && !isForwardRef(element)) {\n    // eslint-disable-next-line no-console\n    console.error('downshift: You returned a non-DOM element. You must specify a refKey in getRootProps');\n  } else if (!isComposite && refKeySpecified) {\n    // eslint-disable-next-line no-console\n    console.error(`downshift: You returned a DOM element. You should not specify a refKey in getRootProps. You specified \"${refKey}\"`);\n  }\n\n  if (!isForwardRef(element) && !getElementProps(element)[refKey]) {\n    // eslint-disable-next-line no-console\n    console.error(`downshift: You must apply the ref prop \"${refKey}\" from getRootProps onto your root element.`);\n  }\n}\n\nconst dropdownDefaultStateValues = {\n  highlightedIndex: -1,\n  isOpen: false,\n  selectedItem: null,\n  inputValue: ''\n};\n\nfunction callOnChangeProps(action, state, newState) {\n  const {\n    props,\n    type\n  } = action;\n  const changes = {};\n  Object.keys(state).forEach(key => {\n    invokeOnChangeHandler(key, action, state, newState);\n\n    if (newState[key] !== state[key]) {\n      changes[key] = newState[key];\n    }\n  });\n\n  if (props.onStateChange && Object.keys(changes).length) {\n    props.onStateChange({\n      type,\n      ...changes\n    });\n  }\n}\n\nfunction invokeOnChangeHandler(key, action, state, newState) {\n  const {\n    props,\n    type\n  } = action;\n  const handler = `on${capitalizeString(key)}Change`;\n\n  if (props[handler] && newState[key] !== undefined && newState[key] !== state[key]) {\n    props[handler]({\n      type,\n      ...newState\n    });\n  }\n}\n/**\n * Default state reducer that returns the changes.\n *\n * @param {Object} s state.\n * @param {Object} a action with changes.\n * @returns {Object} changes.\n */\n\n\nfunction stateReducer(s, a) {\n  return a.changes;\n}\n/**\n * Returns a message to be added to aria-live region when item is selected.\n *\n * @param {Object} selectionParameters Parameters required to build the message.\n * @returns {string} The a11y message.\n */\n\n\nfunction getA11ySelectionMessage(selectionParameters) {\n  const {\n    selectedItem,\n    itemToString: itemToStringLocal\n  } = selectionParameters;\n  return selectedItem ? `${itemToStringLocal(selectedItem)} has been selected.` : '';\n}\n/**\n * Debounced call for updating the a11y message.\n */\n\n\nconst updateA11yStatus = debounce((getA11yMessage, document) => {\n  setStatus(getA11yMessage(), document);\n}, 200); // istanbul ignore next\n\nconst useIsomorphicLayoutEffect = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined' ? useLayoutEffect : useEffect;\n\nfunction useElementIds(_ref) {\n  let {\n    id = `downshift-${generateId()}`,\n    labelId,\n    menuId,\n    getItemId,\n    toggleButtonId,\n    inputId\n  } = _ref;\n  const elementIdsRef = useRef({\n    labelId: labelId || `${id}-label`,\n    menuId: menuId || `${id}-menu`,\n    getItemId: getItemId || (index => `${id}-item-${index}`),\n    toggleButtonId: toggleButtonId || `${id}-toggle-button`,\n    inputId: inputId || `${id}-input`\n  });\n  return elementIdsRef.current;\n}\n\nfunction getItemIndex(index, item, items) {\n  if (index !== undefined) {\n    return index;\n  }\n\n  if (items.length === 0) {\n    return -1;\n  }\n\n  return items.indexOf(item);\n}\n\nfunction itemToString(item) {\n  return item ? String(item) : '';\n}\n\nfunction isAcceptedCharacterKey(key) {\n  return /^\\S{1}$/.test(key);\n}\n\nfunction capitalizeString(string) {\n  return `${string.slice(0, 1).toUpperCase()}${string.slice(1)}`;\n}\n\nfunction useLatestRef(val) {\n  const ref = useRef(val); // technically this is not \"concurrent mode safe\" because we're manipulating\n  // the value during render (so it's not idempotent). However, the places this\n  // hook is used is to support memoizing callbacks which will be called\n  // *during* render, so we need the latest values *during* render.\n  // If not for this, then we'd probably want to use useLayoutEffect instead.\n\n  ref.current = val;\n  return ref;\n}\n/**\n * Computes the controlled state using a the previous state, props,\n * two reducers, one from downshift and an optional one from the user.\n * Also calls the onChange handlers for state values that have changed.\n *\n * @param {Function} reducer Reducer function from downshift.\n * @param {Object} initialState Initial state of the hook.\n * @param {Object} props The hook props.\n * @returns {Array} An array with the state and an action dispatcher.\n */\n\n\nfunction useEnhancedReducer(reducer, initialState, props) {\n  const prevStateRef = useRef();\n  const actionRef = useRef();\n  const enhancedReducer = useCallback((state, action) => {\n    actionRef.current = action;\n    state = getState(state, action.props);\n    const changes = reducer(state, action);\n    const newState = action.props.stateReducer(state, { ...action,\n      changes\n    });\n    return newState;\n  }, [reducer]);\n  const [state, dispatch] = useReducer(enhancedReducer, initialState);\n  const propsRef = useLatestRef(props);\n  const dispatchWithProps = useCallback(action => dispatch({\n    props: propsRef.current,\n    ...action\n  }), [propsRef]);\n  const action = actionRef.current;\n  useEffect(() => {\n    if (action && prevStateRef.current && prevStateRef.current !== state) {\n      callOnChangeProps(action, getState(prevStateRef.current, action.props), state);\n    }\n\n    prevStateRef.current = state;\n  }, [state, props, action]);\n  return [state, dispatchWithProps];\n}\n/**\n * Wraps the useEnhancedReducer and applies the controlled prop values before\n * returning the new state.\n *\n * @param {Function} reducer Reducer function from downshift.\n * @param {Object} initialState Initial state of the hook.\n * @param {Object} props The hook props.\n * @returns {Array} An array with the state and an action dispatcher.\n */\n\n\nfunction useControlledReducer$1(reducer, initialState, props) {\n  const [state, dispatch] = useEnhancedReducer(reducer, initialState, props);\n  return [getState(state, props), dispatch];\n}\n\nconst defaultProps$3 = {\n  itemToString,\n  stateReducer,\n  getA11ySelectionMessage,\n  scrollIntoView,\n  circularNavigation: false,\n  environment:\n  /* istanbul ignore next (ssr) */\n  typeof window === 'undefined' ? {} : window\n};\n\nfunction getDefaultValue$1(props, propKey, defaultStateValues) {\n  if (defaultStateValues === void 0) {\n    defaultStateValues = dropdownDefaultStateValues;\n  }\n\n  const defaultValue = props[`default${capitalizeString(propKey)}`];\n\n  if (defaultValue !== undefined) {\n    return defaultValue;\n  }\n\n  return defaultStateValues[propKey];\n}\n\nfunction getInitialValue$1(props, propKey, defaultStateValues) {\n  if (defaultStateValues === void 0) {\n    defaultStateValues = dropdownDefaultStateValues;\n  }\n\n  const value = props[propKey];\n\n  if (value !== undefined) {\n    return value;\n  }\n\n  const initialValue = props[`initial${capitalizeString(propKey)}`];\n\n  if (initialValue !== undefined) {\n    return initialValue;\n  }\n\n  return getDefaultValue$1(props, propKey, defaultStateValues);\n}\n\nfunction getInitialState$2(props) {\n  const selectedItem = getInitialValue$1(props, 'selectedItem');\n  const isOpen = getInitialValue$1(props, 'isOpen');\n  const highlightedIndex = getInitialValue$1(props, 'highlightedIndex');\n  const inputValue = getInitialValue$1(props, 'inputValue');\n  return {\n    highlightedIndex: highlightedIndex < 0 && selectedItem && isOpen ? props.items.indexOf(selectedItem) : highlightedIndex,\n    isOpen,\n    selectedItem,\n    inputValue\n  };\n}\n\nfunction getHighlightedIndexOnOpen(props, state, offset, getItemNodeFromIndex) {\n  const {\n    items,\n    initialHighlightedIndex,\n    defaultHighlightedIndex\n  } = props;\n  const {\n    selectedItem,\n    highlightedIndex\n  } = state;\n\n  if (items.length === 0) {\n    return -1;\n  } // initialHighlightedIndex will give value to highlightedIndex on initial state only.\n\n\n  if (initialHighlightedIndex !== undefined && highlightedIndex === initialHighlightedIndex) {\n    return initialHighlightedIndex;\n  }\n\n  if (defaultHighlightedIndex !== undefined) {\n    return defaultHighlightedIndex;\n  }\n\n  if (selectedItem) {\n    if (offset === 0) {\n      return items.indexOf(selectedItem);\n    }\n\n    return getNextWrappingIndex(offset, items.indexOf(selectedItem), items.length, getItemNodeFromIndex, false);\n  }\n\n  if (offset === 0) {\n    return -1;\n  }\n\n  return offset < 0 ? items.length - 1 : 0;\n}\n/**\n * Reuse the movement tracking of mouse and touch events.\n *\n * @param {boolean} isOpen Whether the dropdown is open or not.\n * @param {Array<Object>} downshiftElementRefs Downshift element refs to track movement (toggleButton, menu etc.)\n * @param {Object} environment Environment where component/hook exists.\n * @param {Function} handleBlur Handler on blur from mouse or touch.\n * @returns {Object} Ref containing whether mouseDown or touchMove event is happening\n */\n\n\nfunction useMouseAndTouchTracker(isOpen, downshiftElementRefs, environment, handleBlur) {\n  const mouseAndTouchTrackersRef = useRef({\n    isMouseDown: false,\n    isTouchMove: false\n  });\n  useEffect(() => {\n    // The same strategy for checking if a click occurred inside or outside downsift\n    // as in downshift.js.\n    const onMouseDown = () => {\n      mouseAndTouchTrackersRef.current.isMouseDown = true;\n    };\n\n    const onMouseUp = event => {\n      mouseAndTouchTrackersRef.current.isMouseDown = false;\n\n      if (isOpen && !targetWithinDownshift(event.target, downshiftElementRefs.map(ref => ref.current), environment)) {\n        handleBlur();\n      }\n    };\n\n    const onTouchStart = () => {\n      mouseAndTouchTrackersRef.current.isTouchMove = false;\n    };\n\n    const onTouchMove = () => {\n      mouseAndTouchTrackersRef.current.isTouchMove = true;\n    };\n\n    const onTouchEnd = event => {\n      if (isOpen && !mouseAndTouchTrackersRef.current.isTouchMove && !targetWithinDownshift(event.target, downshiftElementRefs.map(ref => ref.current), environment, false)) {\n        handleBlur();\n      }\n    };\n\n    environment.addEventListener('mousedown', onMouseDown);\n    environment.addEventListener('mouseup', onMouseUp);\n    environment.addEventListener('touchstart', onTouchStart);\n    environment.addEventListener('touchmove', onTouchMove);\n    environment.addEventListener('touchend', onTouchEnd);\n    return function cleanup() {\n      environment.removeEventListener('mousedown', onMouseDown);\n      environment.removeEventListener('mouseup', onMouseUp);\n      environment.removeEventListener('touchstart', onTouchStart);\n      environment.removeEventListener('touchmove', onTouchMove);\n      environment.removeEventListener('touchend', onTouchEnd);\n    }; // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [isOpen, environment]);\n  return mouseAndTouchTrackersRef;\n}\n/* istanbul ignore next */\n// eslint-disable-next-line import/no-mutable-exports\n\n\nlet useGetterPropsCalledChecker = () => noop;\n/**\n * Custom hook that checks if getter props are called correctly.\n *\n * @param  {...any} propKeys Getter prop names to be handled.\n * @returns {Function} Setter function called inside getter props to set call information.\n */\n\n/* istanbul ignore next */\n\n\nif (process.env.NODE_ENV !== 'production') {\n  useGetterPropsCalledChecker = function () {\n    const isInitialMountRef = useRef(true);\n\n    for (var _len = arguments.length, propKeys = new Array(_len), _key = 0; _key < _len; _key++) {\n      propKeys[_key] = arguments[_key];\n    }\n\n    const getterPropsCalledRef = useRef(propKeys.reduce((acc, propKey) => {\n      acc[propKey] = {};\n      return acc;\n    }, {}));\n    useEffect(() => {\n      Object.keys(getterPropsCalledRef.current).forEach(propKey => {\n        const propCallInfo = getterPropsCalledRef.current[propKey];\n\n        if (isInitialMountRef.current) {\n          if (!Object.keys(propCallInfo).length) {\n            // eslint-disable-next-line no-console\n            console.error(`downshift: You forgot to call the ${propKey} getter function on your component / element.`);\n            return;\n          }\n        }\n\n        const {\n          suppressRefError,\n          refKey,\n          elementRef\n        } = propCallInfo;\n\n        if ((!elementRef || !elementRef.current) && !suppressRefError) {\n          // eslint-disable-next-line no-console\n          console.error(`downshift: The ref prop \"${refKey}\" from ${propKey} was not applied correctly on your element.`);\n        }\n      });\n      isInitialMountRef.current = false;\n    });\n    const setGetterPropCallInfo = useCallback((propKey, suppressRefError, refKey, elementRef) => {\n      getterPropsCalledRef.current[propKey] = {\n        suppressRefError,\n        refKey,\n        elementRef\n      };\n    }, []);\n    return setGetterPropCallInfo;\n  };\n}\n\nfunction useA11yMessageSetter(getA11yMessage, dependencyArray, _ref2) {\n  let {\n    isInitialMount,\n    highlightedIndex,\n    items,\n    environment,\n    ...rest\n  } = _ref2; // Sets a11y status message on changes in state.\n\n  useEffect(() => {\n    if (isInitialMount || false) {\n      return;\n    }\n\n    updateA11yStatus(() => getA11yMessage({\n      highlightedIndex,\n      highlightedItem: items[highlightedIndex],\n      resultCount: items.length,\n      ...rest\n    }), environment.document); // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, dependencyArray);\n}\n\nfunction useScrollIntoView(_ref3) {\n  let {\n    highlightedIndex,\n    isOpen,\n    itemRefs,\n    getItemNodeFromIndex,\n    menuElement,\n    scrollIntoView: scrollIntoViewProp\n  } = _ref3; // used not to scroll on highlight by mouse.\n\n  const shouldScrollRef = useRef(true); // Scroll on highlighted item if change comes from keyboard.\n\n  useIsomorphicLayoutEffect(() => {\n    if (highlightedIndex < 0 || !isOpen || !Object.keys(itemRefs.current).length) {\n      return;\n    }\n\n    if (shouldScrollRef.current === false) {\n      shouldScrollRef.current = true;\n    } else {\n      scrollIntoViewProp(getItemNodeFromIndex(highlightedIndex), menuElement);\n    } // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, [highlightedIndex]);\n  return shouldScrollRef;\n} // eslint-disable-next-line import/no-mutable-exports\n\n\nlet useControlPropsValidator = noop;\n/* istanbul ignore next */\n\nif (process.env.NODE_ENV !== 'production') {\n  useControlPropsValidator = _ref4 => {\n    let {\n      isInitialMount,\n      props,\n      state\n    } = _ref4; // used for checking when props are moving from controlled to uncontrolled.\n\n    const prevPropsRef = useRef(props);\n    useEffect(() => {\n      if (isInitialMount) {\n        return;\n      }\n\n      validateControlledUnchanged(state, prevPropsRef.current, props);\n      prevPropsRef.current = props;\n    }, [state, props, isInitialMount]);\n  };\n}\n/* eslint-disable complexity */\n\n\nfunction downshiftCommonReducer(state, action, stateChangeTypes) {\n  const {\n    type,\n    props\n  } = action;\n  let changes;\n\n  switch (type) {\n    case stateChangeTypes.ItemMouseMove:\n      changes = {\n        highlightedIndex: action.disabled ? -1 : action.index\n      };\n      break;\n\n    case stateChangeTypes.MenuMouseLeave:\n      changes = {\n        highlightedIndex: -1\n      };\n      break;\n\n    case stateChangeTypes.ToggleButtonClick:\n    case stateChangeTypes.FunctionToggleMenu:\n      changes = {\n        isOpen: !state.isOpen,\n        highlightedIndex: state.isOpen ? -1 : getHighlightedIndexOnOpen(props, state, 0)\n      };\n      break;\n\n    case stateChangeTypes.FunctionOpenMenu:\n      changes = {\n        isOpen: true,\n        highlightedIndex: getHighlightedIndexOnOpen(props, state, 0)\n      };\n      break;\n\n    case stateChangeTypes.FunctionCloseMenu:\n      changes = {\n        isOpen: false\n      };\n      break;\n\n    case stateChangeTypes.FunctionSetHighlightedIndex:\n      changes = {\n        highlightedIndex: action.highlightedIndex\n      };\n      break;\n\n    case stateChangeTypes.FunctionSetInputValue:\n      changes = {\n        inputValue: action.inputValue\n      };\n      break;\n\n    case stateChangeTypes.FunctionReset:\n      changes = {\n        highlightedIndex: getDefaultValue$1(props, 'highlightedIndex'),\n        isOpen: getDefaultValue$1(props, 'isOpen'),\n        selectedItem: getDefaultValue$1(props, 'selectedItem'),\n        inputValue: getDefaultValue$1(props, 'inputValue')\n      };\n      break;\n\n    default:\n      throw new Error('Reducer called without proper action type.');\n  }\n\n  return { ...state,\n    ...changes\n  };\n}\n/* eslint-enable complexity */\n\n\nfunction getItemIndexByCharacterKey(_a) {\n  var keysSoFar = _a.keysSoFar,\n      highlightedIndex = _a.highlightedIndex,\n      items = _a.items,\n      itemToString = _a.itemToString,\n      getItemNodeFromIndex = _a.getItemNodeFromIndex;\n  var lowerCasedKeysSoFar = keysSoFar.toLowerCase();\n\n  for (var index = 0; index < items.length; index++) {\n    var offsetIndex = (index + highlightedIndex + 1) % items.length;\n    var item = items[offsetIndex];\n\n    if (item !== undefined && itemToString(item).toLowerCase().startsWith(lowerCasedKeysSoFar)) {\n      var element = getItemNodeFromIndex(offsetIndex);\n\n      if (!(element === null || element === void 0 ? void 0 : element.hasAttribute('disabled'))) {\n        return offsetIndex;\n      }\n    }\n  }\n\n  return highlightedIndex;\n}\n\nvar propTypes$2 = {\n  items: PropTypes.array.isRequired,\n  itemToString: PropTypes.func,\n  getA11yStatusMessage: PropTypes.func,\n  getA11ySelectionMessage: PropTypes.func,\n  circularNavigation: PropTypes.bool,\n  highlightedIndex: PropTypes.number,\n  defaultHighlightedIndex: PropTypes.number,\n  initialHighlightedIndex: PropTypes.number,\n  isOpen: PropTypes.bool,\n  defaultIsOpen: PropTypes.bool,\n  initialIsOpen: PropTypes.bool,\n  selectedItem: PropTypes.any,\n  initialSelectedItem: PropTypes.any,\n  defaultSelectedItem: PropTypes.any,\n  id: PropTypes.string,\n  labelId: PropTypes.string,\n  menuId: PropTypes.string,\n  getItemId: PropTypes.func,\n  toggleButtonId: PropTypes.string,\n  stateReducer: PropTypes.func,\n  onSelectedItemChange: PropTypes.func,\n  onHighlightedIndexChange: PropTypes.func,\n  onStateChange: PropTypes.func,\n  onIsOpenChange: PropTypes.func,\n  environment: PropTypes.shape({\n    addEventListener: PropTypes.func,\n    removeEventListener: PropTypes.func,\n    document: PropTypes.shape({\n      getElementById: PropTypes.func,\n      activeElement: PropTypes.any,\n      body: PropTypes.any\n    })\n  })\n};\n/**\n * Default implementation for status message. Only added when menu is open.\n * Will specift if there are results in the list, and if so, how many,\n * and what keys are relevant.\n *\n * @param {Object} param the downshift state and other relevant properties\n * @return {String} the a11y status message\n */\n\nfunction getA11yStatusMessage(_a) {\n  var isOpen = _a.isOpen,\n      resultCount = _a.resultCount,\n      previousResultCount = _a.previousResultCount;\n\n  if (!isOpen) {\n    return '';\n  }\n\n  if (!resultCount) {\n    return 'No results are available.';\n  }\n\n  if (resultCount !== previousResultCount) {\n    return \"\".concat(resultCount, \" result\").concat(resultCount === 1 ? ' is' : 's are', \" available, use up and down arrow keys to navigate. Press Enter or Space Bar keys to select.\");\n  }\n\n  return '';\n}\n\nvar defaultProps$2 = __assign(__assign({}, defaultProps$3), {\n  getA11yStatusMessage: getA11yStatusMessage\n}); // eslint-disable-next-line import/no-mutable-exports\n\n\nvar validatePropTypes$2 = noop;\n/* istanbul ignore next */\n\nif (process.env.NODE_ENV !== 'production') {\n  validatePropTypes$2 = function (options, caller) {\n    PropTypes.checkPropTypes(propTypes$2, options, 'prop', caller.name);\n  };\n}\n\nconst MenuKeyDownArrowDown = process.env.NODE_ENV !== \"production\" ? '__menu_keydown_arrow_down__' : 0;\nconst MenuKeyDownArrowUp = process.env.NODE_ENV !== \"production\" ? '__menu_keydown_arrow_up__' : 1;\nconst MenuKeyDownEscape = process.env.NODE_ENV !== \"production\" ? '__menu_keydown_escape__' : 2;\nconst MenuKeyDownHome = process.env.NODE_ENV !== \"production\" ? '__menu_keydown_home__' : 3;\nconst MenuKeyDownEnd = process.env.NODE_ENV !== \"production\" ? '__menu_keydown_end__' : 4;\nconst MenuKeyDownEnter = process.env.NODE_ENV !== \"production\" ? '__menu_keydown_enter__' : 5;\nconst MenuKeyDownSpaceButton = process.env.NODE_ENV !== \"production\" ? '__menu_keydown_space_button__' : 6;\nconst MenuKeyDownCharacter = process.env.NODE_ENV !== \"production\" ? '__menu_keydown_character__' : 7;\nconst MenuBlur = process.env.NODE_ENV !== \"production\" ? '__menu_blur__' : 8;\nconst MenuMouseLeave$1 = process.env.NODE_ENV !== \"production\" ? '__menu_mouse_leave__' : 9;\nconst ItemMouseMove$1 = process.env.NODE_ENV !== \"production\" ? '__item_mouse_move__' : 10;\nconst ItemClick$1 = process.env.NODE_ENV !== \"production\" ? '__item_click__' : 11;\nconst ToggleButtonClick$1 = process.env.NODE_ENV !== \"production\" ? '__togglebutton_click__' : 12;\nconst ToggleButtonKeyDownArrowDown = process.env.NODE_ENV !== \"production\" ? '__togglebutton_keydown_arrow_down__' : 13;\nconst ToggleButtonKeyDownArrowUp = process.env.NODE_ENV !== \"production\" ? '__togglebutton_keydown_arrow_up__' : 14;\nconst ToggleButtonKeyDownCharacter = process.env.NODE_ENV !== \"production\" ? '__togglebutton_keydown_character__' : 15;\nconst FunctionToggleMenu$1 = process.env.NODE_ENV !== \"production\" ? '__function_toggle_menu__' : 16;\nconst FunctionOpenMenu$1 = process.env.NODE_ENV !== \"production\" ? '__function_open_menu__' : 17;\nconst FunctionCloseMenu$1 = process.env.NODE_ENV !== \"production\" ? '__function_close_menu__' : 18;\nconst FunctionSetHighlightedIndex$1 = process.env.NODE_ENV !== \"production\" ? '__function_set_highlighted_index__' : 19;\nconst FunctionSelectItem$1 = process.env.NODE_ENV !== \"production\" ? '__function_select_item__' : 20;\nconst FunctionSetInputValue$1 = process.env.NODE_ENV !== \"production\" ? '__function_set_input_value__' : 21;\nconst FunctionReset$2 = process.env.NODE_ENV !== \"production\" ? '__function_reset__' : 22;\nvar stateChangeTypes$2 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  MenuKeyDownArrowDown: MenuKeyDownArrowDown,\n  MenuKeyDownArrowUp: MenuKeyDownArrowUp,\n  MenuKeyDownEscape: MenuKeyDownEscape,\n  MenuKeyDownHome: MenuKeyDownHome,\n  MenuKeyDownEnd: MenuKeyDownEnd,\n  MenuKeyDownEnter: MenuKeyDownEnter,\n  MenuKeyDownSpaceButton: MenuKeyDownSpaceButton,\n  MenuKeyDownCharacter: MenuKeyDownCharacter,\n  MenuBlur: MenuBlur,\n  MenuMouseLeave: MenuMouseLeave$1,\n  ItemMouseMove: ItemMouseMove$1,\n  ItemClick: ItemClick$1,\n  ToggleButtonClick: ToggleButtonClick$1,\n  ToggleButtonKeyDownArrowDown: ToggleButtonKeyDownArrowDown,\n  ToggleButtonKeyDownArrowUp: ToggleButtonKeyDownArrowUp,\n  ToggleButtonKeyDownCharacter: ToggleButtonKeyDownCharacter,\n  FunctionToggleMenu: FunctionToggleMenu$1,\n  FunctionOpenMenu: FunctionOpenMenu$1,\n  FunctionCloseMenu: FunctionCloseMenu$1,\n  FunctionSetHighlightedIndex: FunctionSetHighlightedIndex$1,\n  FunctionSelectItem: FunctionSelectItem$1,\n  FunctionSetInputValue: FunctionSetInputValue$1,\n  FunctionReset: FunctionReset$2\n});\n/* eslint-disable complexity */\n\nfunction downshiftSelectReducer(state, action) {\n  const {\n    type,\n    props,\n    shiftKey\n  } = action;\n  let changes;\n\n  switch (type) {\n    case ItemClick$1:\n      changes = {\n        isOpen: getDefaultValue$1(props, 'isOpen'),\n        highlightedIndex: getDefaultValue$1(props, 'highlightedIndex'),\n        selectedItem: props.items[action.index]\n      };\n      break;\n\n    case ToggleButtonKeyDownCharacter:\n      {\n        const lowercasedKey = action.key;\n        const inputValue = `${state.inputValue}${lowercasedKey}`;\n        const itemIndex = getItemIndexByCharacterKey({\n          keysSoFar: inputValue,\n          highlightedIndex: state.selectedItem ? props.items.indexOf(state.selectedItem) : -1,\n          items: props.items,\n          itemToString: props.itemToString,\n          getItemNodeFromIndex: action.getItemNodeFromIndex\n        });\n        changes = {\n          inputValue,\n          ...(itemIndex >= 0 && {\n            selectedItem: props.items[itemIndex]\n          })\n        };\n      }\n      break;\n\n    case ToggleButtonKeyDownArrowDown:\n      changes = {\n        highlightedIndex: getHighlightedIndexOnOpen(props, state, 1, action.getItemNodeFromIndex),\n        isOpen: true\n      };\n      break;\n\n    case ToggleButtonKeyDownArrowUp:\n      changes = {\n        highlightedIndex: getHighlightedIndexOnOpen(props, state, -1, action.getItemNodeFromIndex),\n        isOpen: true\n      };\n      break;\n\n    case MenuKeyDownEnter:\n    case MenuKeyDownSpaceButton:\n      changes = {\n        isOpen: getDefaultValue$1(props, 'isOpen'),\n        highlightedIndex: getDefaultValue$1(props, 'highlightedIndex'),\n        ...(state.highlightedIndex >= 0 && {\n          selectedItem: props.items[state.highlightedIndex]\n        })\n      };\n      break;\n\n    case MenuKeyDownHome:\n      changes = {\n        highlightedIndex: getNextNonDisabledIndex(1, 0, props.items.length, action.getItemNodeFromIndex, false)\n      };\n      break;\n\n    case MenuKeyDownEnd:\n      changes = {\n        highlightedIndex: getNextNonDisabledIndex(-1, props.items.length - 1, props.items.length, action.getItemNodeFromIndex, false)\n      };\n      break;\n\n    case MenuKeyDownEscape:\n      changes = {\n        isOpen: false,\n        highlightedIndex: -1\n      };\n      break;\n\n    case MenuBlur:\n      changes = {\n        isOpen: false,\n        highlightedIndex: -1\n      };\n      break;\n\n    case MenuKeyDownCharacter:\n      {\n        const lowercasedKey = action.key;\n        const inputValue = `${state.inputValue}${lowercasedKey}`;\n        const highlightedIndex = getItemIndexByCharacterKey({\n          keysSoFar: inputValue,\n          highlightedIndex: state.highlightedIndex,\n          items: props.items,\n          itemToString: props.itemToString,\n          getItemNodeFromIndex: action.getItemNodeFromIndex\n        });\n        changes = {\n          inputValue,\n          ...(highlightedIndex >= 0 && {\n            highlightedIndex\n          })\n        };\n      }\n      break;\n\n    case MenuKeyDownArrowDown:\n      changes = {\n        highlightedIndex: getNextWrappingIndex(shiftKey ? 5 : 1, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, props.circularNavigation)\n      };\n      break;\n\n    case MenuKeyDownArrowUp:\n      changes = {\n        highlightedIndex: getNextWrappingIndex(shiftKey ? -5 : -1, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, props.circularNavigation)\n      };\n      break;\n\n    case FunctionSelectItem$1:\n      changes = {\n        selectedItem: action.selectedItem\n      };\n      break;\n\n    default:\n      return downshiftCommonReducer(state, action, stateChangeTypes$2);\n  }\n\n  return { ...state,\n    ...changes\n  };\n}\n/* eslint-enable complexity */\n\n/* eslint-disable max-statements */\n\n\nuseSelect.stateChangeTypes = stateChangeTypes$2;\n\nfunction useSelect(userProps) {\n  if (userProps === void 0) {\n    userProps = {};\n  }\n\n  validatePropTypes$2(userProps, useSelect); // Props defaults and destructuring.\n\n  const props = { ...defaultProps$2,\n    ...userProps\n  };\n  const {\n    items,\n    scrollIntoView,\n    environment,\n    initialIsOpen,\n    defaultIsOpen,\n    itemToString,\n    getA11ySelectionMessage,\n    getA11yStatusMessage\n  } = props; // Initial state depending on controlled props.\n\n  const initialState = getInitialState$2(props);\n  const [state, dispatch] = useControlledReducer$1(downshiftSelectReducer, initialState, props);\n  const {\n    isOpen,\n    highlightedIndex,\n    selectedItem,\n    inputValue\n  } = state; // Element efs.\n\n  const toggleButtonRef = useRef(null);\n  const menuRef = useRef(null);\n  const itemRefs = useRef({}); // used not to trigger menu blur action in some scenarios.\n\n  const shouldBlurRef = useRef(true); // used to keep the inputValue clearTimeout object between renders.\n\n  const clearTimeoutRef = useRef(null); // prevent id re-generation between renders.\n\n  const elementIds = useElementIds(props); // used to keep track of how many items we had on previous cycle.\n\n  const previousResultCountRef = useRef();\n  const isInitialMountRef = useRef(true); // utility callback to get item element.\n\n  const latest = useLatestRef({\n    state,\n    props\n  }); // Some utils.\n\n  const getItemNodeFromIndex = useCallback(index => itemRefs.current[elementIds.getItemId(index)], [elementIds]); // Effects.\n  // Sets a11y status message on changes in state.\n\n  useA11yMessageSetter(getA11yStatusMessage, [isOpen, highlightedIndex, inputValue, items], {\n    isInitialMount: isInitialMountRef.current,\n    previousResultCount: previousResultCountRef.current,\n    items,\n    environment,\n    itemToString,\n    ...state\n  }); // Sets a11y status message on changes in selectedItem.\n\n  useA11yMessageSetter(getA11ySelectionMessage, [selectedItem], {\n    isInitialMount: isInitialMountRef.current,\n    previousResultCount: previousResultCountRef.current,\n    items,\n    environment,\n    itemToString,\n    ...state\n  }); // Scroll on highlighted item if change comes from keyboard.\n\n  const shouldScrollRef = useScrollIntoView({\n    menuElement: menuRef.current,\n    highlightedIndex,\n    isOpen,\n    itemRefs,\n    scrollIntoView,\n    getItemNodeFromIndex\n  }); // Sets cleanup for the keysSoFar callback, debounded after 500ms.\n\n  useEffect(() => {\n    // init the clean function here as we need access to dispatch.\n    clearTimeoutRef.current = debounce(outerDispatch => {\n      outerDispatch({\n        type: FunctionSetInputValue$1,\n        inputValue: ''\n      });\n    }, 500); // Cancel any pending debounced calls on mount\n\n    return () => {\n      clearTimeoutRef.current.cancel();\n    };\n  }, []); // Invokes the keysSoFar callback set up above.\n\n  useEffect(() => {\n    if (!inputValue) {\n      return;\n    }\n\n    clearTimeoutRef.current(dispatch);\n  }, [dispatch, inputValue]);\n  useControlPropsValidator({\n    isInitialMount: isInitialMountRef.current,\n    props,\n    state\n  });\n  /* Controls the focus on the menu or the toggle button. */\n\n  useEffect(() => {\n    // Don't focus menu on first render.\n    if (isInitialMountRef.current) {\n      // Unless it was initialised as open.\n      if ((initialIsOpen || defaultIsOpen || isOpen) && menuRef.current) {\n        menuRef.current.focus();\n      }\n\n      return;\n    } // Focus menu on open.\n\n\n    if (isOpen) {\n      // istanbul ignore else\n      if (menuRef.current) {\n        menuRef.current.focus();\n      }\n\n      return;\n    } // Focus toggleButton on close, but not if it was closed with (Shift+)Tab.\n\n\n    if (environment.document.activeElement === menuRef.current) {\n      // istanbul ignore else\n      if (toggleButtonRef.current) {\n        shouldBlurRef.current = false;\n        toggleButtonRef.current.focus();\n      }\n    } // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, [isOpen]);\n  useEffect(() => {\n    if (isInitialMountRef.current) {\n      return;\n    }\n\n    previousResultCountRef.current = items.length;\n  }); // Add mouse/touch events to document.\n\n  const mouseAndTouchTrackersRef = useMouseAndTouchTracker(isOpen, [menuRef, toggleButtonRef], environment, () => {\n    dispatch({\n      type: MenuBlur\n    });\n  });\n  const setGetterPropCallInfo = useGetterPropsCalledChecker('getMenuProps', 'getToggleButtonProps'); // Make initial ref false.\n\n  useEffect(() => {\n    isInitialMountRef.current = false;\n  }, []); // Reset itemRefs on close.\n\n  useEffect(() => {\n    if (!isOpen) {\n      itemRefs.current = {};\n    }\n  }, [isOpen]); // Event handler functions.\n\n  const toggleButtonKeyDownHandlers = useMemo(() => ({\n    ArrowDown(event) {\n      event.preventDefault();\n      dispatch({\n        type: ToggleButtonKeyDownArrowDown,\n        getItemNodeFromIndex,\n        shiftKey: event.shiftKey\n      });\n    },\n\n    ArrowUp(event) {\n      event.preventDefault();\n      dispatch({\n        type: ToggleButtonKeyDownArrowUp,\n        getItemNodeFromIndex,\n        shiftKey: event.shiftKey\n      });\n    }\n\n  }), [dispatch, getItemNodeFromIndex]);\n  const menuKeyDownHandlers = useMemo(() => ({\n    ArrowDown(event) {\n      event.preventDefault();\n      dispatch({\n        type: MenuKeyDownArrowDown,\n        getItemNodeFromIndex,\n        shiftKey: event.shiftKey\n      });\n    },\n\n    ArrowUp(event) {\n      event.preventDefault();\n      dispatch({\n        type: MenuKeyDownArrowUp,\n        getItemNodeFromIndex,\n        shiftKey: event.shiftKey\n      });\n    },\n\n    Home(event) {\n      event.preventDefault();\n      dispatch({\n        type: MenuKeyDownHome,\n        getItemNodeFromIndex\n      });\n    },\n\n    End(event) {\n      event.preventDefault();\n      dispatch({\n        type: MenuKeyDownEnd,\n        getItemNodeFromIndex\n      });\n    },\n\n    Escape() {\n      dispatch({\n        type: MenuKeyDownEscape\n      });\n    },\n\n    Enter(event) {\n      event.preventDefault();\n      dispatch({\n        type: MenuKeyDownEnter\n      });\n    },\n\n    ' '(event) {\n      event.preventDefault();\n      dispatch({\n        type: MenuKeyDownSpaceButton\n      });\n    }\n\n  }), [dispatch, getItemNodeFromIndex]); // Action functions.\n\n  const toggleMenu = useCallback(() => {\n    dispatch({\n      type: FunctionToggleMenu$1\n    });\n  }, [dispatch]);\n  const closeMenu = useCallback(() => {\n    dispatch({\n      type: FunctionCloseMenu$1\n    });\n  }, [dispatch]);\n  const openMenu = useCallback(() => {\n    dispatch({\n      type: FunctionOpenMenu$1\n    });\n  }, [dispatch]);\n  const setHighlightedIndex = useCallback(newHighlightedIndex => {\n    dispatch({\n      type: FunctionSetHighlightedIndex$1,\n      highlightedIndex: newHighlightedIndex\n    });\n  }, [dispatch]);\n  const selectItem = useCallback(newSelectedItem => {\n    dispatch({\n      type: FunctionSelectItem$1,\n      selectedItem: newSelectedItem\n    });\n  }, [dispatch]);\n  const reset = useCallback(() => {\n    dispatch({\n      type: FunctionReset$2\n    });\n  }, [dispatch]);\n  const setInputValue = useCallback(newInputValue => {\n    dispatch({\n      type: FunctionSetInputValue$1,\n      inputValue: newInputValue\n    });\n  }, [dispatch]); // Getter functions.\n\n  const getLabelProps = useCallback(labelProps => ({\n    id: elementIds.labelId,\n    htmlFor: elementIds.toggleButtonId,\n    ...labelProps\n  }), [elementIds]);\n  const getMenuProps = useCallback(function (_temp, _temp2) {\n    let {\n      onMouseLeave,\n      refKey = 'ref',\n      onKeyDown,\n      onBlur,\n      ref,\n      ...rest\n    } = _temp === void 0 ? {} : _temp;\n    let {\n      suppressRefError = false\n    } = _temp2 === void 0 ? {} : _temp2;\n    const latestState = latest.current.state;\n\n    const menuHandleKeyDown = event => {\n      const key = normalizeArrowKey(event);\n\n      if (key && menuKeyDownHandlers[key]) {\n        menuKeyDownHandlers[key](event);\n      } else if (isAcceptedCharacterKey(key)) {\n        dispatch({\n          type: MenuKeyDownCharacter,\n          key,\n          getItemNodeFromIndex\n        });\n      }\n    };\n\n    const menuHandleBlur = () => {\n      // if the blur was a result of selection, we don't trigger this action.\n      if (shouldBlurRef.current === false) {\n        shouldBlurRef.current = true;\n        return;\n      }\n\n      const shouldBlur = !mouseAndTouchTrackersRef.current.isMouseDown;\n      /* istanbul ignore else */\n\n      if (shouldBlur) {\n        dispatch({\n          type: MenuBlur\n        });\n      }\n    };\n\n    const menuHandleMouseLeave = () => {\n      dispatch({\n        type: MenuMouseLeave$1\n      });\n    };\n\n    setGetterPropCallInfo('getMenuProps', suppressRefError, refKey, menuRef);\n    return {\n      [refKey]: handleRefs(ref, menuNode => {\n        menuRef.current = menuNode;\n      }),\n      id: elementIds.menuId,\n      role: 'listbox',\n      'aria-labelledby': elementIds.labelId,\n      tabIndex: -1,\n      ...(latestState.isOpen && latestState.highlightedIndex > -1 && {\n        'aria-activedescendant': elementIds.getItemId(latestState.highlightedIndex)\n      }),\n      onMouseLeave: callAllEventHandlers(onMouseLeave, menuHandleMouseLeave),\n      onKeyDown: callAllEventHandlers(onKeyDown, menuHandleKeyDown),\n      onBlur: callAllEventHandlers(onBlur, menuHandleBlur),\n      ...rest\n    };\n  }, [dispatch, latest, menuKeyDownHandlers, mouseAndTouchTrackersRef, setGetterPropCallInfo, elementIds, getItemNodeFromIndex]);\n  const getToggleButtonProps = useCallback(function (_temp3, _temp4) {\n    let {\n      onClick,\n      onKeyDown,\n      refKey = 'ref',\n      ref,\n      ...rest\n    } = _temp3 === void 0 ? {} : _temp3;\n    let {\n      suppressRefError = false\n    } = _temp4 === void 0 ? {} : _temp4;\n\n    const toggleButtonHandleClick = () => {\n      dispatch({\n        type: ToggleButtonClick$1\n      });\n    };\n\n    const toggleButtonHandleKeyDown = event => {\n      const key = normalizeArrowKey(event);\n\n      if (key && toggleButtonKeyDownHandlers[key]) {\n        toggleButtonKeyDownHandlers[key](event);\n      } else if (isAcceptedCharacterKey(key)) {\n        dispatch({\n          type: ToggleButtonKeyDownCharacter,\n          key,\n          getItemNodeFromIndex\n        });\n      }\n    };\n\n    const toggleProps = {\n      [refKey]: handleRefs(ref, toggleButtonNode => {\n        toggleButtonRef.current = toggleButtonNode;\n      }),\n      id: elementIds.toggleButtonId,\n      'aria-haspopup': 'listbox',\n      'aria-expanded': latest.current.state.isOpen,\n      'aria-labelledby': `${elementIds.labelId} ${elementIds.toggleButtonId}`,\n      ...rest\n    };\n\n    if (!rest.disabled) {\n      toggleProps.onClick = callAllEventHandlers(onClick, toggleButtonHandleClick);\n      toggleProps.onKeyDown = callAllEventHandlers(onKeyDown, toggleButtonHandleKeyDown);\n    }\n\n    setGetterPropCallInfo('getToggleButtonProps', suppressRefError, refKey, toggleButtonRef);\n    return toggleProps;\n  }, [dispatch, latest, toggleButtonKeyDownHandlers, setGetterPropCallInfo, elementIds, getItemNodeFromIndex]);\n  const getItemProps = useCallback(function (_temp5) {\n    let {\n      item,\n      index,\n      onMouseMove,\n      onClick,\n      refKey = 'ref',\n      ref,\n      disabled,\n      ...rest\n    } = _temp5 === void 0 ? {} : _temp5;\n    const {\n      state: latestState,\n      props: latestProps\n    } = latest.current;\n\n    const itemHandleMouseMove = () => {\n      if (index === latestState.highlightedIndex) {\n        return;\n      }\n\n      shouldScrollRef.current = false;\n      dispatch({\n        type: ItemMouseMove$1,\n        index,\n        disabled\n      });\n    };\n\n    const itemHandleClick = () => {\n      dispatch({\n        type: ItemClick$1,\n        index\n      });\n    };\n\n    const itemIndex = getItemIndex(index, item, latestProps.items);\n\n    if (itemIndex < 0) {\n      throw new Error('Pass either item or item index in getItemProps!');\n    }\n\n    const itemProps = {\n      disabled,\n      role: 'option',\n      'aria-selected': `${itemIndex === latestState.highlightedIndex}`,\n      id: elementIds.getItemId(itemIndex),\n      [refKey]: handleRefs(ref, itemNode => {\n        if (itemNode) {\n          itemRefs.current[elementIds.getItemId(itemIndex)] = itemNode;\n        }\n      }),\n      ...rest\n    };\n\n    if (!disabled) {\n      itemProps.onClick = callAllEventHandlers(onClick, itemHandleClick);\n    }\n\n    itemProps.onMouseMove = callAllEventHandlers(onMouseMove, itemHandleMouseMove);\n    return itemProps;\n  }, [dispatch, latest, shouldScrollRef, elementIds]);\n  return {\n    // prop getters.\n    getToggleButtonProps,\n    getLabelProps,\n    getMenuProps,\n    getItemProps,\n    // actions.\n    toggleMenu,\n    openMenu,\n    closeMenu,\n    setHighlightedIndex,\n    selectItem,\n    reset,\n    setInputValue,\n    // state.\n    highlightedIndex,\n    isOpen,\n    selectedItem,\n    inputValue\n  };\n}\n\nconst InputKeyDownArrowDown = process.env.NODE_ENV !== \"production\" ? '__input_keydown_arrow_down__' : 0;\nconst InputKeyDownArrowUp = process.env.NODE_ENV !== \"production\" ? '__input_keydown_arrow_up__' : 1;\nconst InputKeyDownEscape = process.env.NODE_ENV !== \"production\" ? '__input_keydown_escape__' : 2;\nconst InputKeyDownHome = process.env.NODE_ENV !== \"production\" ? '__input_keydown_home__' : 3;\nconst InputKeyDownEnd = process.env.NODE_ENV !== \"production\" ? '__input_keydown_end__' : 4;\nconst InputKeyDownEnter = process.env.NODE_ENV !== \"production\" ? '__input_keydown_enter__' : 5;\nconst InputChange = process.env.NODE_ENV !== \"production\" ? '__input_change__' : 6;\nconst InputBlur = process.env.NODE_ENV !== \"production\" ? '__input_blur__' : 7;\nconst MenuMouseLeave = process.env.NODE_ENV !== \"production\" ? '__menu_mouse_leave__' : 8;\nconst ItemMouseMove = process.env.NODE_ENV !== \"production\" ? '__item_mouse_move__' : 9;\nconst ItemClick = process.env.NODE_ENV !== \"production\" ? '__item_click__' : 10;\nconst ToggleButtonClick = process.env.NODE_ENV !== \"production\" ? '__togglebutton_click__' : 11;\nconst FunctionToggleMenu = process.env.NODE_ENV !== \"production\" ? '__function_toggle_menu__' : 12;\nconst FunctionOpenMenu = process.env.NODE_ENV !== \"production\" ? '__function_open_menu__' : 13;\nconst FunctionCloseMenu = process.env.NODE_ENV !== \"production\" ? '__function_close_menu__' : 14;\nconst FunctionSetHighlightedIndex = process.env.NODE_ENV !== \"production\" ? '__function_set_highlighted_index__' : 15;\nconst FunctionSelectItem = process.env.NODE_ENV !== \"production\" ? '__function_select_item__' : 16;\nconst FunctionSetInputValue = process.env.NODE_ENV !== \"production\" ? '__function_set_input_value__' : 17;\nconst FunctionReset$1 = process.env.NODE_ENV !== \"production\" ? '__function_reset__' : 18;\nconst ControlledPropUpdatedSelectedItem = process.env.NODE_ENV !== \"production\" ? '__controlled_prop_updated_selected_item__' : 19;\nvar stateChangeTypes$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  InputKeyDownArrowDown: InputKeyDownArrowDown,\n  InputKeyDownArrowUp: InputKeyDownArrowUp,\n  InputKeyDownEscape: InputKeyDownEscape,\n  InputKeyDownHome: InputKeyDownHome,\n  InputKeyDownEnd: InputKeyDownEnd,\n  InputKeyDownEnter: InputKeyDownEnter,\n  InputChange: InputChange,\n  InputBlur: InputBlur,\n  MenuMouseLeave: MenuMouseLeave,\n  ItemMouseMove: ItemMouseMove,\n  ItemClick: ItemClick,\n  ToggleButtonClick: ToggleButtonClick,\n  FunctionToggleMenu: FunctionToggleMenu,\n  FunctionOpenMenu: FunctionOpenMenu,\n  FunctionCloseMenu: FunctionCloseMenu,\n  FunctionSetHighlightedIndex: FunctionSetHighlightedIndex,\n  FunctionSelectItem: FunctionSelectItem,\n  FunctionSetInputValue: FunctionSetInputValue,\n  FunctionReset: FunctionReset$1,\n  ControlledPropUpdatedSelectedItem: ControlledPropUpdatedSelectedItem\n});\n\nfunction getInitialState$1(props) {\n  const initialState = getInitialState$2(props);\n  const {\n    selectedItem\n  } = initialState;\n  let {\n    inputValue\n  } = initialState;\n\n  if (inputValue === '' && selectedItem && props.defaultInputValue === undefined && props.initialInputValue === undefined && props.inputValue === undefined) {\n    inputValue = props.itemToString(selectedItem);\n  }\n\n  return { ...initialState,\n    inputValue\n  };\n}\n\nconst propTypes$1 = {\n  items: PropTypes.array.isRequired,\n  itemToString: PropTypes.func,\n  getA11yStatusMessage: PropTypes.func,\n  getA11ySelectionMessage: PropTypes.func,\n  circularNavigation: PropTypes.bool,\n  highlightedIndex: PropTypes.number,\n  defaultHighlightedIndex: PropTypes.number,\n  initialHighlightedIndex: PropTypes.number,\n  isOpen: PropTypes.bool,\n  defaultIsOpen: PropTypes.bool,\n  initialIsOpen: PropTypes.bool,\n  selectedItem: PropTypes.any,\n  initialSelectedItem: PropTypes.any,\n  defaultSelectedItem: PropTypes.any,\n  inputValue: PropTypes.string,\n  defaultInputValue: PropTypes.string,\n  initialInputValue: PropTypes.string,\n  id: PropTypes.string,\n  labelId: PropTypes.string,\n  menuId: PropTypes.string,\n  getItemId: PropTypes.func,\n  inputId: PropTypes.string,\n  toggleButtonId: PropTypes.string,\n  stateReducer: PropTypes.func,\n  onSelectedItemChange: PropTypes.func,\n  onHighlightedIndexChange: PropTypes.func,\n  onStateChange: PropTypes.func,\n  onIsOpenChange: PropTypes.func,\n  onInputValueChange: PropTypes.func,\n  environment: PropTypes.shape({\n    addEventListener: PropTypes.func,\n    removeEventListener: PropTypes.func,\n    document: PropTypes.shape({\n      getElementById: PropTypes.func,\n      activeElement: PropTypes.any,\n      body: PropTypes.any\n    })\n  })\n};\n/**\n * The useCombobox version of useControlledReducer, which also\n * checks if the controlled prop selectedItem changed between\n * renders. If so, it will also update inputValue with its\n * string equivalent. It uses the common useEnhancedReducer to\n * compute the rest of the state.\n *\n * @param {Function} reducer Reducer function from downshift.\n * @param {Object} initialState Initial state of the hook.\n * @param {Object} props The hook props.\n * @returns {Array} An array with the state and an action dispatcher.\n */\n\nfunction useControlledReducer(reducer, initialState, props) {\n  const previousSelectedItemRef = useRef();\n  const [state, dispatch] = useEnhancedReducer(reducer, initialState, props); // ToDo: if needed, make same approach as selectedItemChanged from Downshift.\n\n  useEffect(() => {\n    if (isControlledProp(props, 'selectedItem')) {\n      if (previousSelectedItemRef.current !== props.selectedItem) {\n        dispatch({\n          type: ControlledPropUpdatedSelectedItem,\n          inputValue: props.itemToString(props.selectedItem)\n        });\n      }\n\n      previousSelectedItemRef.current = state.selectedItem === previousSelectedItemRef.current ? props.selectedItem : state.selectedItem;\n    }\n  });\n  return [getState(state, props), dispatch];\n} // eslint-disable-next-line import/no-mutable-exports\n\n\nlet validatePropTypes$1 = noop;\n/* istanbul ignore next */\n\nif (process.env.NODE_ENV !== 'production') {\n  validatePropTypes$1 = (options, caller) => {\n    PropTypes.checkPropTypes(propTypes$1, options, 'prop', caller.name);\n  };\n}\n\nconst defaultProps$1 = { ...defaultProps$3,\n  getA11yStatusMessage: getA11yStatusMessage$1,\n  circularNavigation: true\n};\n/* eslint-disable complexity */\n\nfunction downshiftUseComboboxReducer(state, action) {\n  const {\n    type,\n    props,\n    shiftKey\n  } = action;\n  let changes;\n\n  switch (type) {\n    case ItemClick:\n      changes = {\n        isOpen: getDefaultValue$1(props, 'isOpen'),\n        highlightedIndex: getDefaultValue$1(props, 'highlightedIndex'),\n        selectedItem: props.items[action.index],\n        inputValue: props.itemToString(props.items[action.index])\n      };\n      break;\n\n    case InputKeyDownArrowDown:\n      if (state.isOpen) {\n        changes = {\n          highlightedIndex: getNextWrappingIndex(shiftKey ? 5 : 1, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, props.circularNavigation)\n        };\n      } else {\n        changes = {\n          highlightedIndex: getHighlightedIndexOnOpen(props, state, 1, action.getItemNodeFromIndex),\n          isOpen: props.items.length >= 0\n        };\n      }\n\n      break;\n\n    case InputKeyDownArrowUp:\n      if (state.isOpen) {\n        changes = {\n          highlightedIndex: getNextWrappingIndex(shiftKey ? -5 : -1, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, props.circularNavigation)\n        };\n      } else {\n        changes = {\n          highlightedIndex: getHighlightedIndexOnOpen(props, state, -1, action.getItemNodeFromIndex),\n          isOpen: props.items.length >= 0\n        };\n      }\n\n      break;\n\n    case InputKeyDownEnter:\n      changes = { ...(state.isOpen && state.highlightedIndex >= 0 && {\n          selectedItem: props.items[state.highlightedIndex],\n          isOpen: getDefaultValue$1(props, 'isOpen'),\n          highlightedIndex: getDefaultValue$1(props, 'highlightedIndex'),\n          inputValue: props.itemToString(props.items[state.highlightedIndex])\n        })\n      };\n      break;\n\n    case InputKeyDownEscape:\n      changes = {\n        isOpen: false,\n        highlightedIndex: -1,\n        ...(!state.isOpen && {\n          selectedItem: null,\n          inputValue: ''\n        })\n      };\n      break;\n\n    case InputKeyDownHome:\n      changes = {\n        highlightedIndex: getNextNonDisabledIndex(1, 0, props.items.length, action.getItemNodeFromIndex, false)\n      };\n      break;\n\n    case InputKeyDownEnd:\n      changes = {\n        highlightedIndex: getNextNonDisabledIndex(-1, props.items.length - 1, props.items.length, action.getItemNodeFromIndex, false)\n      };\n      break;\n\n    case InputBlur:\n      changes = {\n        isOpen: false,\n        highlightedIndex: -1,\n        ...(state.highlightedIndex >= 0 && action.selectItem && {\n          selectedItem: props.items[state.highlightedIndex],\n          inputValue: props.itemToString(props.items[state.highlightedIndex])\n        })\n      };\n      break;\n\n    case InputChange:\n      changes = {\n        isOpen: true,\n        highlightedIndex: getDefaultValue$1(props, 'highlightedIndex'),\n        inputValue: action.inputValue\n      };\n      break;\n\n    case FunctionSelectItem:\n      changes = {\n        selectedItem: action.selectedItem,\n        inputValue: props.itemToString(action.selectedItem)\n      };\n      break;\n\n    case ControlledPropUpdatedSelectedItem:\n      changes = {\n        inputValue: action.inputValue\n      };\n      break;\n\n    default:\n      return downshiftCommonReducer(state, action, stateChangeTypes$1);\n  }\n\n  return { ...state,\n    ...changes\n  };\n}\n/* eslint-enable complexity */\n\n/* eslint-disable max-statements */\n\n\nuseCombobox.stateChangeTypes = stateChangeTypes$1;\n\nfunction useCombobox(userProps) {\n  if (userProps === void 0) {\n    userProps = {};\n  }\n\n  validatePropTypes$1(userProps, useCombobox); // Props defaults and destructuring.\n\n  const props = { ...defaultProps$1,\n    ...userProps\n  };\n  const {\n    initialIsOpen,\n    defaultIsOpen,\n    items,\n    scrollIntoView,\n    environment,\n    getA11yStatusMessage,\n    getA11ySelectionMessage,\n    itemToString\n  } = props; // Initial state depending on controlled props.\n\n  const initialState = getInitialState$1(props);\n  const [state, dispatch] = useControlledReducer(downshiftUseComboboxReducer, initialState, props);\n  const {\n    isOpen,\n    highlightedIndex,\n    selectedItem,\n    inputValue\n  } = state; // Element refs.\n\n  const menuRef = useRef(null);\n  const itemRefs = useRef({});\n  const inputRef = useRef(null);\n  const toggleButtonRef = useRef(null);\n  const comboboxRef = useRef(null);\n  const isInitialMountRef = useRef(true); // prevent id re-generation between renders.\n\n  const elementIds = useElementIds(props); // used to keep track of how many items we had on previous cycle.\n\n  const previousResultCountRef = useRef(); // utility callback to get item element.\n\n  const latest = useLatestRef({\n    state,\n    props\n  });\n  const getItemNodeFromIndex = useCallback(index => itemRefs.current[elementIds.getItemId(index)], [elementIds]); // Effects.\n  // Sets a11y status message on changes in state.\n\n  useA11yMessageSetter(getA11yStatusMessage, [isOpen, highlightedIndex, inputValue, items], {\n    isInitialMount: isInitialMountRef.current,\n    previousResultCount: previousResultCountRef.current,\n    items,\n    environment,\n    itemToString,\n    ...state\n  }); // Sets a11y status message on changes in selectedItem.\n\n  useA11yMessageSetter(getA11ySelectionMessage, [selectedItem], {\n    isInitialMount: isInitialMountRef.current,\n    previousResultCount: previousResultCountRef.current,\n    items,\n    environment,\n    itemToString,\n    ...state\n  }); // Scroll on highlighted item if change comes from keyboard.\n\n  const shouldScrollRef = useScrollIntoView({\n    menuElement: menuRef.current,\n    highlightedIndex,\n    isOpen,\n    itemRefs,\n    scrollIntoView,\n    getItemNodeFromIndex\n  });\n  useControlPropsValidator({\n    isInitialMount: isInitialMountRef.current,\n    props,\n    state\n  }); // Focus the input on first render if required.\n\n  useEffect(() => {\n    const focusOnOpen = initialIsOpen || defaultIsOpen || isOpen;\n\n    if (focusOnOpen && inputRef.current) {\n      inputRef.current.focus();\n    } // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, []);\n  useEffect(() => {\n    if (isInitialMountRef.current) {\n      return;\n    }\n\n    previousResultCountRef.current = items.length;\n  }); // Add mouse/touch events to document.\n\n  const mouseAndTouchTrackersRef = useMouseAndTouchTracker(isOpen, [comboboxRef, menuRef, toggleButtonRef], environment, () => {\n    dispatch({\n      type: InputBlur,\n      selectItem: false\n    });\n  });\n  const setGetterPropCallInfo = useGetterPropsCalledChecker('getInputProps', 'getComboboxProps', 'getMenuProps'); // Make initial ref false.\n\n  useEffect(() => {\n    isInitialMountRef.current = false;\n  }, []); // Reset itemRefs on close.\n\n  useEffect(() => {\n    if (!isOpen) {\n      itemRefs.current = {};\n    }\n  }, [isOpen]);\n  /* Event handler functions */\n\n  const inputKeyDownHandlers = useMemo(() => ({\n    ArrowDown(event) {\n      event.preventDefault();\n      dispatch({\n        type: InputKeyDownArrowDown,\n        shiftKey: event.shiftKey,\n        getItemNodeFromIndex\n      });\n    },\n\n    ArrowUp(event) {\n      event.preventDefault();\n      dispatch({\n        type: InputKeyDownArrowUp,\n        shiftKey: event.shiftKey,\n        getItemNodeFromIndex\n      });\n    },\n\n    Home(event) {\n      if (!latest.current.state.isOpen) {\n        return;\n      }\n\n      event.preventDefault();\n      dispatch({\n        type: InputKeyDownHome,\n        getItemNodeFromIndex\n      });\n    },\n\n    End(event) {\n      if (!latest.current.state.isOpen) {\n        return;\n      }\n\n      event.preventDefault();\n      dispatch({\n        type: InputKeyDownEnd,\n        getItemNodeFromIndex\n      });\n    },\n\n    Escape(event) {\n      const latestState = latest.current.state;\n\n      if (latestState.isOpen || latestState.inputValue || latestState.selectedItem || latestState.highlightedIndex > -1) {\n        event.preventDefault();\n        dispatch({\n          type: InputKeyDownEscape\n        });\n      }\n    },\n\n    Enter(event) {\n      const latestState = latest.current.state; // if closed or no highlighted index, do nothing.\n\n      if (!latestState.isOpen || latestState.highlightedIndex < 0 || event.which === 229 // if IME composing, wait for next Enter keydown event.\n      ) {\n        return;\n      }\n\n      event.preventDefault();\n      dispatch({\n        type: InputKeyDownEnter,\n        getItemNodeFromIndex\n      });\n    }\n\n  }), [dispatch, latest, getItemNodeFromIndex]); // Getter props.\n\n  const getLabelProps = useCallback(labelProps => ({\n    id: elementIds.labelId,\n    htmlFor: elementIds.inputId,\n    ...labelProps\n  }), [elementIds]);\n  const getMenuProps = useCallback(function (_temp, _temp2) {\n    let {\n      onMouseLeave,\n      refKey = 'ref',\n      ref,\n      ...rest\n    } = _temp === void 0 ? {} : _temp;\n    let {\n      suppressRefError = false\n    } = _temp2 === void 0 ? {} : _temp2;\n    setGetterPropCallInfo('getMenuProps', suppressRefError, refKey, menuRef);\n    return {\n      [refKey]: handleRefs(ref, menuNode => {\n        menuRef.current = menuNode;\n      }),\n      id: elementIds.menuId,\n      role: 'listbox',\n      'aria-labelledby': elementIds.labelId,\n      onMouseLeave: callAllEventHandlers(onMouseLeave, () => {\n        dispatch({\n          type: MenuMouseLeave\n        });\n      }),\n      ...rest\n    };\n  }, [dispatch, setGetterPropCallInfo, elementIds]);\n  const getItemProps = useCallback(function (_temp3) {\n    let {\n      item,\n      index,\n      refKey = 'ref',\n      ref,\n      onMouseMove,\n      onMouseDown,\n      onClick,\n      onPress,\n      disabled,\n      ...rest\n    } = _temp3 === void 0 ? {} : _temp3;\n    const {\n      props: latestProps,\n      state: latestState\n    } = latest.current;\n    const itemIndex = getItemIndex(index, item, latestProps.items);\n\n    if (itemIndex < 0) {\n      throw new Error('Pass either item or item index in getItemProps!');\n    }\n\n    const onSelectKey = 'onClick';\n    const customClickHandler = onClick;\n\n    const itemHandleMouseMove = () => {\n      if (index === latestState.highlightedIndex) {\n        return;\n      }\n\n      shouldScrollRef.current = false;\n      dispatch({\n        type: ItemMouseMove,\n        index,\n        disabled\n      });\n    };\n\n    const itemHandleClick = () => {\n      dispatch({\n        type: ItemClick,\n        index\n      });\n    };\n\n    const itemHandleMouseDown = e => e.preventDefault();\n\n    return {\n      [refKey]: handleRefs(ref, itemNode => {\n        if (itemNode) {\n          itemRefs.current[elementIds.getItemId(itemIndex)] = itemNode;\n        }\n      }),\n      disabled,\n      role: 'option',\n      'aria-selected': `${itemIndex === latestState.highlightedIndex}`,\n      id: elementIds.getItemId(itemIndex),\n      ...(!disabled && {\n        [onSelectKey]: callAllEventHandlers(customClickHandler, itemHandleClick)\n      }),\n      onMouseMove: callAllEventHandlers(onMouseMove, itemHandleMouseMove),\n      onMouseDown: callAllEventHandlers(onMouseDown, itemHandleMouseDown),\n      ...rest\n    };\n  }, [dispatch, latest, shouldScrollRef, elementIds]);\n  const getToggleButtonProps = useCallback(function (_temp4) {\n    let {\n      onClick,\n      onPress,\n      refKey = 'ref',\n      ref,\n      ...rest\n    } = _temp4 === void 0 ? {} : _temp4;\n\n    const toggleButtonHandleClick = () => {\n      dispatch({\n        type: ToggleButtonClick\n      });\n\n      if (!latest.current.state.isOpen && inputRef.current) {\n        inputRef.current.focus();\n      }\n    };\n\n    return {\n      [refKey]: handleRefs(ref, toggleButtonNode => {\n        toggleButtonRef.current = toggleButtonNode;\n      }),\n      id: elementIds.toggleButtonId,\n      tabIndex: -1,\n      ...(!rest.disabled && { ...{\n          onClick: callAllEventHandlers(onClick, toggleButtonHandleClick)\n        }\n      }),\n      ...rest\n    };\n  }, [dispatch, latest, elementIds]);\n  const getInputProps = useCallback(function (_temp5, _temp6) {\n    let {\n      onKeyDown,\n      onChange,\n      onInput,\n      onBlur,\n      onChangeText,\n      refKey = 'ref',\n      ref,\n      ...rest\n    } = _temp5 === void 0 ? {} : _temp5;\n    let {\n      suppressRefError = false\n    } = _temp6 === void 0 ? {} : _temp6;\n    setGetterPropCallInfo('getInputProps', suppressRefError, refKey, inputRef);\n    const latestState = latest.current.state;\n\n    const inputHandleKeyDown = event => {\n      const key = normalizeArrowKey(event);\n\n      if (key && inputKeyDownHandlers[key]) {\n        inputKeyDownHandlers[key](event);\n      }\n    };\n\n    const inputHandleChange = event => {\n      dispatch({\n        type: InputChange,\n        inputValue: event.target.value\n      });\n    };\n\n    const inputHandleBlur = () => {\n      /* istanbul ignore else */\n      if (latestState.isOpen && !mouseAndTouchTrackersRef.current.isMouseDown) {\n        dispatch({\n          type: InputBlur,\n          selectItem: true\n        });\n      }\n    };\n    /* istanbul ignore next (preact) */\n\n\n    const onChangeKey = 'onChange';\n    let eventHandlers = {};\n\n    if (!rest.disabled) {\n      eventHandlers = {\n        [onChangeKey]: callAllEventHandlers(onChange, onInput, inputHandleChange),\n        onKeyDown: callAllEventHandlers(onKeyDown, inputHandleKeyDown),\n        onBlur: callAllEventHandlers(onBlur, inputHandleBlur)\n      };\n    }\n\n    return {\n      [refKey]: handleRefs(ref, inputNode => {\n        inputRef.current = inputNode;\n      }),\n      id: elementIds.inputId,\n      'aria-autocomplete': 'list',\n      'aria-controls': elementIds.menuId,\n      ...(latestState.isOpen && latestState.highlightedIndex > -1 && {\n        'aria-activedescendant': elementIds.getItemId(latestState.highlightedIndex)\n      }),\n      'aria-labelledby': elementIds.labelId,\n      // https://developer.mozilla.org/en-US/docs/Web/Security/Securing_your_site/Turning_off_form_autocompletion\n      // revert back since autocomplete=\"nope\" is ignored on latest Chrome and Opera\n      autoComplete: 'off',\n      value: latestState.inputValue,\n      ...eventHandlers,\n      ...rest\n    };\n  }, [dispatch, inputKeyDownHandlers, latest, mouseAndTouchTrackersRef, setGetterPropCallInfo, elementIds]);\n  const getComboboxProps = useCallback(function (_temp7, _temp8) {\n    let {\n      refKey = 'ref',\n      ref,\n      ...rest\n    } = _temp7 === void 0 ? {} : _temp7;\n    let {\n      suppressRefError = false\n    } = _temp8 === void 0 ? {} : _temp8;\n    setGetterPropCallInfo('getComboboxProps', suppressRefError, refKey, comboboxRef);\n    return {\n      [refKey]: handleRefs(ref, comboboxNode => {\n        comboboxRef.current = comboboxNode;\n      }),\n      role: 'combobox',\n      'aria-haspopup': 'listbox',\n      'aria-owns': elementIds.menuId,\n      'aria-expanded': latest.current.state.isOpen,\n      ...rest\n    };\n  }, [latest, setGetterPropCallInfo, elementIds]); // returns\n\n  const toggleMenu = useCallback(() => {\n    dispatch({\n      type: FunctionToggleMenu\n    });\n  }, [dispatch]);\n  const closeMenu = useCallback(() => {\n    dispatch({\n      type: FunctionCloseMenu\n    });\n  }, [dispatch]);\n  const openMenu = useCallback(() => {\n    dispatch({\n      type: FunctionOpenMenu\n    });\n  }, [dispatch]);\n  const setHighlightedIndex = useCallback(newHighlightedIndex => {\n    dispatch({\n      type: FunctionSetHighlightedIndex,\n      highlightedIndex: newHighlightedIndex\n    });\n  }, [dispatch]);\n  const selectItem = useCallback(newSelectedItem => {\n    dispatch({\n      type: FunctionSelectItem,\n      selectedItem: newSelectedItem\n    });\n  }, [dispatch]);\n  const setInputValue = useCallback(newInputValue => {\n    dispatch({\n      type: FunctionSetInputValue,\n      inputValue: newInputValue\n    });\n  }, [dispatch]);\n  const reset = useCallback(() => {\n    dispatch({\n      type: FunctionReset$1\n    });\n  }, [dispatch]);\n  return {\n    // prop getters.\n    getItemProps,\n    getLabelProps,\n    getMenuProps,\n    getInputProps,\n    getComboboxProps,\n    getToggleButtonProps,\n    // actions.\n    toggleMenu,\n    openMenu,\n    closeMenu,\n    setHighlightedIndex,\n    setInputValue,\n    selectItem,\n    reset,\n    // state.\n    highlightedIndex,\n    isOpen,\n    selectedItem,\n    inputValue\n  };\n}\n\nconst defaultStateValues = {\n  activeIndex: -1,\n  selectedItems: []\n};\n/**\n * Returns the initial value for a state key in the following order:\n * 1. controlled prop, 2. initial prop, 3. default prop, 4. default\n * value from Downshift.\n *\n * @param {Object} props Props passed to the hook.\n * @param {string} propKey Props key to generate the value for.\n * @returns {any} The initial value for that prop.\n */\n\nfunction getInitialValue(props, propKey) {\n  return getInitialValue$1(props, propKey, defaultStateValues);\n}\n/**\n * Returns the default value for a state key in the following order:\n * 1. controlled prop, 2. default prop, 3. default value from Downshift.\n *\n * @param {Object} props Props passed to the hook.\n * @param {string} propKey Props key to generate the value for.\n * @returns {any} The initial value for that prop.\n */\n\n\nfunction getDefaultValue(props, propKey) {\n  return getDefaultValue$1(props, propKey, defaultStateValues);\n}\n/**\n * Gets the initial state based on the provided props. It uses initial, default\n * and controlled props related to state in order to compute the initial value.\n *\n * @param {Object} props Props passed to the hook.\n * @returns {Object} The initial state.\n */\n\n\nfunction getInitialState(props) {\n  const activeIndex = getInitialValue(props, 'activeIndex');\n  const selectedItems = getInitialValue(props, 'selectedItems');\n  return {\n    activeIndex,\n    selectedItems\n  };\n}\n/**\n * Returns true if dropdown keydown operation is permitted. Should not be\n * allowed on keydown with modifier keys (ctrl, alt, shift, meta), on\n * input element with text content that is either highlighted or selection\n * cursor is not at the starting position.\n *\n * @param {KeyboardEvent} event The event from keydown.\n * @returns {boolean} Whether the operation is allowed.\n */\n\n\nfunction isKeyDownOperationPermitted(event) {\n  if (event.shiftKey || event.metaKey || event.ctrlKey || event.altKey) {\n    return false;\n  }\n\n  const element = event.target;\n\n  if (element instanceof HTMLInputElement && // if element is a text input\n  element.value !== '' && ( // and we have text in it\n  // and cursor is either not at the start or is currently highlighting text.\n  element.selectionStart !== 0 || element.selectionEnd !== 0)) {\n    return false;\n  }\n\n  return true;\n}\n/**\n * Returns a message to be added to aria-live region when item is removed.\n *\n * @param {Object} selectionParameters Parameters required to build the message.\n * @returns {string} The a11y message.\n */\n\n\nfunction getA11yRemovalMessage(selectionParameters) {\n  const {\n    removedSelectedItem,\n    itemToString: itemToStringLocal\n  } = selectionParameters;\n  return `${itemToStringLocal(removedSelectedItem)} has been removed.`;\n}\n\nconst propTypes = {\n  selectedItems: PropTypes.array,\n  initialSelectedItems: PropTypes.array,\n  defaultSelectedItems: PropTypes.array,\n  itemToString: PropTypes.func,\n  getA11yRemovalMessage: PropTypes.func,\n  stateReducer: PropTypes.func,\n  activeIndex: PropTypes.number,\n  initialActiveIndex: PropTypes.number,\n  defaultActiveIndex: PropTypes.number,\n  onActiveIndexChange: PropTypes.func,\n  onSelectedItemsChange: PropTypes.func,\n  keyNavigationNext: PropTypes.string,\n  keyNavigationPrevious: PropTypes.string,\n  environment: PropTypes.shape({\n    addEventListener: PropTypes.func,\n    removeEventListener: PropTypes.func,\n    document: PropTypes.shape({\n      getElementById: PropTypes.func,\n      activeElement: PropTypes.any,\n      body: PropTypes.any\n    })\n  })\n};\nconst defaultProps = {\n  itemToString: defaultProps$3.itemToString,\n  stateReducer: defaultProps$3.stateReducer,\n  environment: defaultProps$3.environment,\n  getA11yRemovalMessage,\n  keyNavigationNext: 'ArrowRight',\n  keyNavigationPrevious: 'ArrowLeft'\n}; // eslint-disable-next-line import/no-mutable-exports\n\nlet validatePropTypes = noop;\n/* istanbul ignore next */\n\nif (process.env.NODE_ENV !== 'production') {\n  validatePropTypes = (options, caller) => {\n    PropTypes.checkPropTypes(propTypes, options, 'prop', caller.name);\n  };\n}\n\nconst SelectedItemClick = process.env.NODE_ENV !== \"production\" ? '__selected_item_click__' : 0;\nconst SelectedItemKeyDownDelete = process.env.NODE_ENV !== \"production\" ? '__selected_item_keydown_delete__' : 1;\nconst SelectedItemKeyDownBackspace = process.env.NODE_ENV !== \"production\" ? '__selected_item_keydown_backspace__' : 2;\nconst SelectedItemKeyDownNavigationNext = process.env.NODE_ENV !== \"production\" ? '__selected_item_keydown_navigation_next__' : 3;\nconst SelectedItemKeyDownNavigationPrevious = process.env.NODE_ENV !== \"production\" ? '__selected_item_keydown_navigation_previous__' : 4;\nconst DropdownKeyDownNavigationPrevious = process.env.NODE_ENV !== \"production\" ? '__dropdown_keydown_navigation_previous__' : 5;\nconst DropdownKeyDownBackspace = process.env.NODE_ENV !== \"production\" ? '__dropdown_keydown_backspace__' : 6;\nconst DropdownClick = process.env.NODE_ENV !== \"production\" ? '__dropdown_click__' : 7;\nconst FunctionAddSelectedItem = process.env.NODE_ENV !== \"production\" ? '__function_add_selected_item__' : 8;\nconst FunctionRemoveSelectedItem = process.env.NODE_ENV !== \"production\" ? '__function_remove_selected_item__' : 9;\nconst FunctionSetSelectedItems = process.env.NODE_ENV !== \"production\" ? '__function_set_selected_items__' : 10;\nconst FunctionSetActiveIndex = process.env.NODE_ENV !== \"production\" ? '__function_set_active_index__' : 11;\nconst FunctionReset = process.env.NODE_ENV !== \"production\" ? '__function_reset__' : 12;\nvar stateChangeTypes = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  SelectedItemClick: SelectedItemClick,\n  SelectedItemKeyDownDelete: SelectedItemKeyDownDelete,\n  SelectedItemKeyDownBackspace: SelectedItemKeyDownBackspace,\n  SelectedItemKeyDownNavigationNext: SelectedItemKeyDownNavigationNext,\n  SelectedItemKeyDownNavigationPrevious: SelectedItemKeyDownNavigationPrevious,\n  DropdownKeyDownNavigationPrevious: DropdownKeyDownNavigationPrevious,\n  DropdownKeyDownBackspace: DropdownKeyDownBackspace,\n  DropdownClick: DropdownClick,\n  FunctionAddSelectedItem: FunctionAddSelectedItem,\n  FunctionRemoveSelectedItem: FunctionRemoveSelectedItem,\n  FunctionSetSelectedItems: FunctionSetSelectedItems,\n  FunctionSetActiveIndex: FunctionSetActiveIndex,\n  FunctionReset: FunctionReset\n});\n/* eslint-disable complexity */\n\nfunction downshiftMultipleSelectionReducer(state, action) {\n  const {\n    type,\n    index,\n    props,\n    selectedItem\n  } = action;\n  const {\n    activeIndex,\n    selectedItems\n  } = state;\n  let changes;\n\n  switch (type) {\n    case SelectedItemClick:\n      changes = {\n        activeIndex: index\n      };\n      break;\n\n    case SelectedItemKeyDownNavigationPrevious:\n      changes = {\n        activeIndex: activeIndex - 1 < 0 ? 0 : activeIndex - 1\n      };\n      break;\n\n    case SelectedItemKeyDownNavigationNext:\n      changes = {\n        activeIndex: activeIndex + 1 >= selectedItems.length ? -1 : activeIndex + 1\n      };\n      break;\n\n    case SelectedItemKeyDownBackspace:\n    case SelectedItemKeyDownDelete:\n      {\n        let newActiveIndex = activeIndex;\n\n        if (selectedItems.length === 1) {\n          newActiveIndex = -1;\n        } else if (activeIndex === selectedItems.length - 1) {\n          newActiveIndex = selectedItems.length - 2;\n        }\n\n        changes = {\n          selectedItems: [...selectedItems.slice(0, activeIndex), ...selectedItems.slice(activeIndex + 1)],\n          ...{\n            activeIndex: newActiveIndex\n          }\n        };\n        break;\n      }\n\n    case DropdownKeyDownNavigationPrevious:\n      changes = {\n        activeIndex: selectedItems.length - 1\n      };\n      break;\n\n    case DropdownKeyDownBackspace:\n      changes = {\n        selectedItems: selectedItems.slice(0, selectedItems.length - 1)\n      };\n      break;\n\n    case FunctionAddSelectedItem:\n      changes = {\n        selectedItems: [...selectedItems, selectedItem]\n      };\n      break;\n\n    case DropdownClick:\n      changes = {\n        activeIndex: -1\n      };\n      break;\n\n    case FunctionRemoveSelectedItem:\n      {\n        let newActiveIndex = activeIndex;\n        const selectedItemIndex = selectedItems.indexOf(selectedItem);\n\n        if (selectedItemIndex >= 0) {\n          if (selectedItems.length === 1) {\n            newActiveIndex = -1;\n          } else if (selectedItemIndex === selectedItems.length - 1) {\n            newActiveIndex = selectedItems.length - 2;\n          }\n\n          changes = {\n            selectedItems: [...selectedItems.slice(0, selectedItemIndex), ...selectedItems.slice(selectedItemIndex + 1)],\n            activeIndex: newActiveIndex\n          };\n        }\n\n        break;\n      }\n\n    case FunctionSetSelectedItems:\n      {\n        const {\n          selectedItems: newSelectedItems\n        } = action;\n        changes = {\n          selectedItems: newSelectedItems\n        };\n        break;\n      }\n\n    case FunctionSetActiveIndex:\n      {\n        const {\n          activeIndex: newActiveIndex\n        } = action;\n        changes = {\n          activeIndex: newActiveIndex\n        };\n        break;\n      }\n\n    case FunctionReset:\n      changes = {\n        activeIndex: getDefaultValue(props, 'activeIndex'),\n        selectedItems: getDefaultValue(props, 'selectedItems')\n      };\n      break;\n\n    default:\n      throw new Error('Reducer called without proper action type.');\n  }\n\n  return { ...state,\n    ...changes\n  };\n}\n\nuseMultipleSelection.stateChangeTypes = stateChangeTypes;\n\nfunction useMultipleSelection(userProps) {\n  if (userProps === void 0) {\n    userProps = {};\n  }\n\n  validatePropTypes(userProps, useMultipleSelection); // Props defaults and destructuring.\n\n  const props = { ...defaultProps,\n    ...userProps\n  };\n  const {\n    getA11yRemovalMessage,\n    itemToString,\n    environment,\n    keyNavigationNext,\n    keyNavigationPrevious\n  } = props; // Reducer init.\n\n  const [state, dispatch] = useControlledReducer$1(downshiftMultipleSelectionReducer, getInitialState(props), props);\n  const {\n    activeIndex,\n    selectedItems\n  } = state; // Refs.\n\n  const isInitialMountRef = useRef(true);\n  const dropdownRef = useRef(null);\n  const previousSelectedItemsRef = useRef(selectedItems);\n  const selectedItemRefs = useRef();\n  selectedItemRefs.current = [];\n  const latest = useLatestRef({\n    state,\n    props\n  }); // Effects.\n\n  /* Sets a11y status message on changes in selectedItem. */\n\n  useEffect(() => {\n    if (isInitialMountRef.current) {\n      return;\n    }\n\n    if (selectedItems.length < previousSelectedItemsRef.current.length) {\n      const removedSelectedItem = previousSelectedItemsRef.current.find(item => selectedItems.indexOf(item) < 0);\n      setStatus(getA11yRemovalMessage({\n        itemToString,\n        resultCount: selectedItems.length,\n        removedSelectedItem,\n        activeIndex,\n        activeSelectedItem: selectedItems[activeIndex]\n      }), environment.document);\n    }\n\n    previousSelectedItemsRef.current = selectedItems; // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [selectedItems.length]); // Sets focus on active item.\n\n  useEffect(() => {\n    if (isInitialMountRef.current) {\n      return;\n    }\n\n    if (activeIndex === -1 && dropdownRef.current) {\n      dropdownRef.current.focus();\n    } else if (selectedItemRefs.current[activeIndex]) {\n      selectedItemRefs.current[activeIndex].focus();\n    }\n  }, [activeIndex]);\n  useControlPropsValidator({\n    isInitialMount: isInitialMountRef.current,\n    props,\n    state\n  });\n  const setGetterPropCallInfo = useGetterPropsCalledChecker('getDropdownProps'); // Make initial ref false.\n\n  useEffect(() => {\n    isInitialMountRef.current = false;\n  }, []); // Event handler functions.\n\n  const selectedItemKeyDownHandlers = useMemo(() => ({\n    [keyNavigationPrevious]() {\n      dispatch({\n        type: SelectedItemKeyDownNavigationPrevious\n      });\n    },\n\n    [keyNavigationNext]() {\n      dispatch({\n        type: SelectedItemKeyDownNavigationNext\n      });\n    },\n\n    Delete() {\n      dispatch({\n        type: SelectedItemKeyDownDelete\n      });\n    },\n\n    Backspace() {\n      dispatch({\n        type: SelectedItemKeyDownBackspace\n      });\n    }\n\n  }), [dispatch, keyNavigationNext, keyNavigationPrevious]);\n  const dropdownKeyDownHandlers = useMemo(() => ({\n    [keyNavigationPrevious](event) {\n      if (isKeyDownOperationPermitted(event)) {\n        dispatch({\n          type: DropdownKeyDownNavigationPrevious\n        });\n      }\n    },\n\n    Backspace(event) {\n      if (isKeyDownOperationPermitted(event)) {\n        dispatch({\n          type: DropdownKeyDownBackspace\n        });\n      }\n    }\n\n  }), [dispatch, keyNavigationPrevious]); // Getter props.\n\n  const getSelectedItemProps = useCallback(function (_temp) {\n    let {\n      refKey = 'ref',\n      ref,\n      onClick,\n      onKeyDown,\n      selectedItem,\n      index,\n      ...rest\n    } = _temp === void 0 ? {} : _temp;\n    const {\n      state: latestState\n    } = latest.current;\n    const itemIndex = getItemIndex(index, selectedItem, latestState.selectedItems);\n\n    if (itemIndex < 0) {\n      throw new Error('Pass either selectedItem or index in getSelectedItemProps!');\n    }\n\n    const selectedItemHandleClick = () => {\n      dispatch({\n        type: SelectedItemClick,\n        index\n      });\n    };\n\n    const selectedItemHandleKeyDown = event => {\n      const key = normalizeArrowKey(event);\n\n      if (key && selectedItemKeyDownHandlers[key]) {\n        selectedItemKeyDownHandlers[key](event);\n      }\n    };\n\n    return {\n      [refKey]: handleRefs(ref, selectedItemNode => {\n        if (selectedItemNode) {\n          selectedItemRefs.current.push(selectedItemNode);\n        }\n      }),\n      tabIndex: index === latestState.activeIndex ? 0 : -1,\n      onClick: callAllEventHandlers(onClick, selectedItemHandleClick),\n      onKeyDown: callAllEventHandlers(onKeyDown, selectedItemHandleKeyDown),\n      ...rest\n    };\n  }, [dispatch, latest, selectedItemKeyDownHandlers]);\n  const getDropdownProps = useCallback(function (_temp2, _temp3) {\n    let {\n      refKey = 'ref',\n      ref,\n      onKeyDown,\n      onClick,\n      preventKeyAction = false,\n      ...rest\n    } = _temp2 === void 0 ? {} : _temp2;\n    let {\n      suppressRefError = false\n    } = _temp3 === void 0 ? {} : _temp3;\n    setGetterPropCallInfo('getDropdownProps', suppressRefError, refKey, dropdownRef);\n\n    const dropdownHandleKeyDown = event => {\n      const key = normalizeArrowKey(event);\n\n      if (key && dropdownKeyDownHandlers[key]) {\n        dropdownKeyDownHandlers[key](event);\n      }\n    };\n\n    const dropdownHandleClick = () => {\n      dispatch({\n        type: DropdownClick\n      });\n    };\n\n    return {\n      [refKey]: handleRefs(ref, dropdownNode => {\n        if (dropdownNode) {\n          dropdownRef.current = dropdownNode;\n        }\n      }),\n      ...(!preventKeyAction && {\n        onKeyDown: callAllEventHandlers(onKeyDown, dropdownHandleKeyDown),\n        onClick: callAllEventHandlers(onClick, dropdownHandleClick)\n      }),\n      ...rest\n    };\n  }, [dispatch, dropdownKeyDownHandlers, setGetterPropCallInfo]); // returns\n\n  const addSelectedItem = useCallback(selectedItem => {\n    dispatch({\n      type: FunctionAddSelectedItem,\n      selectedItem\n    });\n  }, [dispatch]);\n  const removeSelectedItem = useCallback(selectedItem => {\n    dispatch({\n      type: FunctionRemoveSelectedItem,\n      selectedItem\n    });\n  }, [dispatch]);\n  const setSelectedItems = useCallback(newSelectedItems => {\n    dispatch({\n      type: FunctionSetSelectedItems,\n      selectedItems: newSelectedItems\n    });\n  }, [dispatch]);\n  const setActiveIndex = useCallback(newActiveIndex => {\n    dispatch({\n      type: FunctionSetActiveIndex,\n      activeIndex: newActiveIndex\n    });\n  }, [dispatch]);\n  const reset = useCallback(() => {\n    dispatch({\n      type: FunctionReset\n    });\n  }, [dispatch]);\n  return {\n    getSelectedItemProps,\n    getDropdownProps,\n    addSelectedItem,\n    removeSelectedItem,\n    setSelectedItems,\n    setActiveIndex,\n    reset,\n    selectedItems,\n    activeIndex\n  };\n}\n\nexport { Downshift$1 as default, resetIdCounter, useCombobox, useMultipleSelection, useSelect };","map":{"version":3,"names":["PropTypes","Component","cloneElement","useRef","useEffect","useCallback","useLayoutEffect","useReducer","useMemo","isForwardRef","computeScrollIntoView","__assign","idCounter","cbToCb","cb","noop","scrollIntoView","node","menuNode","actions","boundary","block","scrollMode","forEach","_ref","el","top","left","scrollTop","scrollLeft","isOrContainsNode","parent","child","environment","result","Node","contains","debounce","fn","time","timeoutId","cancel","clearTimeout","wrapper","_len","arguments","length","args","Array","_key","setTimeout","callAllEventHandlers","_len2","fns","_key2","event","_len3","_key3","some","preventDownshiftDefault","hasOwnProperty","nativeEvent","handleRefs","_len4","refs","_key4","ref","current","generateId","String","resetIdCounter","getA11yStatusMessage$1","_ref2","isOpen","resultCount","previousResultCount","unwrapArray","arg","defaultValue","isArray","isDOMElement","element","type","getElementProps","props","requiredProp","fnName","propName","console","error","stateKeys","pickState","state","k","getState","Object","keys","reduce","prevState","key","isControlledProp","undefined","normalizeArrowKey","keyCode","indexOf","isPlainObject","obj","prototype","toString","call","getNextWrappingIndex","moveAmount","baseIndex","itemCount","getItemNodeFromIndex","circular","itemsLastIndex","newIndex","nonDisabledNewIndex","getNextNonDisabledIndex","currentElementNode","hasAttribute","index","targetWithinDownshift","target","downshiftElements","checkActiveElement","contextNode","document","activeElement","validateControlledUnchanged","process","env","NODE_ENV","prevProps","nextProps","warningDescription","propKey","cleanupStatus","documentProp","getStatusDiv","textContent","setStatus","status","div","statusDiv","getElementById","createElement","setAttribute","assign","style","border","clip","height","margin","overflow","padding","position","width","body","appendChild","unknown","mouseUp","itemMouseEnter","keyDownArrowUp","keyDownArrowDown","keyDownEscape","keyDownEnter","keyDownHome","keyDownEnd","clickItem","blurInput","changeInput","keyDownSpaceButton","clickButton","blurButton","controlledPropUpdatedSelectedItem","touchEnd","stateChangeTypes$3","freeze","__proto__","Downshift","constructor","_props","_this","id","menuId","labelId","inputId","getItemId","input","items","timeoutIds","internalSetTimeout","filter","i","push","setItemCount","count","unsetItemCount","setHighlightedIndex","highlightedIndex","otherStateToSet","defaultHighlightedIndex","internalSetState","clearSelection","selectedItem","inputValue","defaultIsOpen","selectItem","item","itemToString","selectItemAtIndex","itemIndex","selectHighlightedItem","stateToSet","isItemSelected","onChangeArg","onStateChangeArg","isStateToSetFunction","onInputValueChange","getStateAndHelpers","setState","newStateToSet","stateReducer","nextState","hasMoreStateThanType","onStateChange","onSelect","onChange","onUserAction","rootRef","_rootNode","getRootProps","_temp","_temp2","refKey","rest","suppressRefError","called","role","keyDownHandlers","ArrowDown","preventDefault","amount","shiftKey","moveHighlightedIndex","getItemCount","nextHighlightedIndex","ArrowUp","Enter","which","itemNode","Escape","reset","buttonKeyDownHandlers","toggleMenu","inputKeyDownHandlers","Home","newHighlightedIndex","End","getToggleButtonProps","_temp3","onClick","onPress","onKeyDown","onKeyUp","onBlur","enabledEventHandlers","buttonHandleClick","buttonHandleKeyDown","buttonHandleKeyUp","buttonHandleBlur","eventHandlers","disabled","focus","blurTarget","isMouseDown","getLabelProps","htmlFor","getInputProps","_temp4","onInput","onChangeText","onChangeKey","inputHandleChange","inputHandleKeyDown","inputHandleBlur","autoComplete","value","downshiftButtonIsActive","dataset","toggle","menuRef","_menuNode","getMenuProps","_temp5","_temp6","getItemProps","_temp7","onMouseMove","onMouseDown","onSelectKey","customClickHandler","avoidScrolling","clearItems","openMenu","closeMenu","updateStatus","getA11yStatusMessage","highlightedItem","initialHighlightedIndex","_highlightedIndex","initialIsOpen","_isOpen","initialInputValue","_inputValue","initialSelectedItem","_selectedItem","_state","internalClearTimeouts","stateToMerge","scrollHighlightedItemIntoView","componentDidMount","validateGetMenuPropsCalledCorrectly","onMouseUp","contextWithinDownshift","onOuterClick","onTouchStart","isTouchMove","onTouchMove","onTouchEnd","addEventListener","cleanup","removeEventListener","shouldScroll","currentHighlightedIndex","prevHighlightedIndex","scrollWhenOpen","scrollWhenNavigating","componentDidUpdate","selectedItemChanged","componentWillUnmount","render","children","validateGetRootPropsCalledCorrectly","Error","defaultProps","warn","prevItem","window","stateChangeTypes","propTypes","func","number","bool","any","string","shape","Downshift$1","_ref3","_ref4","refKeySpecified","isComposite","dropdownDefaultStateValues","callOnChangeProps","action","newState","changes","invokeOnChangeHandler","handler","capitalizeString","s","a","getA11ySelectionMessage","selectionParameters","itemToStringLocal","updateA11yStatus","getA11yMessage","useIsomorphicLayoutEffect","useElementIds","toggleButtonId","elementIdsRef","getItemIndex","isAcceptedCharacterKey","test","slice","toUpperCase","useLatestRef","val","useEnhancedReducer","reducer","initialState","prevStateRef","actionRef","enhancedReducer","dispatch","propsRef","dispatchWithProps","useControlledReducer$1","defaultProps$3","circularNavigation","getDefaultValue$1","defaultStateValues","getInitialValue$1","initialValue","getInitialState$2","getHighlightedIndexOnOpen","offset","useMouseAndTouchTracker","downshiftElementRefs","handleBlur","mouseAndTouchTrackersRef","map","useGetterPropsCalledChecker","isInitialMountRef","propKeys","getterPropsCalledRef","acc","propCallInfo","elementRef","setGetterPropCallInfo","useA11yMessageSetter","dependencyArray","isInitialMount","useScrollIntoView","itemRefs","menuElement","scrollIntoViewProp","shouldScrollRef","useControlPropsValidator","prevPropsRef","downshiftCommonReducer","ItemMouseMove","MenuMouseLeave","ToggleButtonClick","FunctionToggleMenu","FunctionOpenMenu","FunctionCloseMenu","FunctionSetHighlightedIndex","FunctionSetInputValue","FunctionReset","getItemIndexByCharacterKey","_a","keysSoFar","lowerCasedKeysSoFar","toLowerCase","offsetIndex","startsWith","propTypes$2","array","isRequired","defaultSelectedItem","onSelectedItemChange","onHighlightedIndexChange","onIsOpenChange","concat","defaultProps$2","validatePropTypes$2","options","caller","checkPropTypes","name","MenuKeyDownArrowDown","MenuKeyDownArrowUp","MenuKeyDownEscape","MenuKeyDownHome","MenuKeyDownEnd","MenuKeyDownEnter","MenuKeyDownSpaceButton","MenuKeyDownCharacter","MenuBlur","MenuMouseLeave$1","ItemMouseMove$1","ItemClick$1","ToggleButtonClick$1","ToggleButtonKeyDownArrowDown","ToggleButtonKeyDownArrowUp","ToggleButtonKeyDownCharacter","FunctionToggleMenu$1","FunctionOpenMenu$1","FunctionCloseMenu$1","FunctionSetHighlightedIndex$1","FunctionSelectItem$1","FunctionSetInputValue$1","FunctionReset$2","stateChangeTypes$2","ItemClick","FunctionSelectItem","downshiftSelectReducer","lowercasedKey","useSelect","userProps","toggleButtonRef","shouldBlurRef","clearTimeoutRef","elementIds","previousResultCountRef","latest","outerDispatch","toggleButtonKeyDownHandlers","menuKeyDownHandlers","newSelectedItem","setInputValue","newInputValue","labelProps","onMouseLeave","latestState","menuHandleKeyDown","menuHandleBlur","shouldBlur","menuHandleMouseLeave","tabIndex","toggleButtonHandleClick","toggleButtonHandleKeyDown","toggleProps","toggleButtonNode","latestProps","itemHandleMouseMove","itemHandleClick","itemProps","InputKeyDownArrowDown","InputKeyDownArrowUp","InputKeyDownEscape","InputKeyDownHome","InputKeyDownEnd","InputKeyDownEnter","InputChange","InputBlur","FunctionReset$1","ControlledPropUpdatedSelectedItem","stateChangeTypes$1","getInitialState$1","defaultInputValue","propTypes$1","useControlledReducer","previousSelectedItemRef","validatePropTypes$1","defaultProps$1","downshiftUseComboboxReducer","useCombobox","inputRef","comboboxRef","focusOnOpen","itemHandleMouseDown","e","inputNode","getComboboxProps","_temp8","comboboxNode","activeIndex","selectedItems","getInitialValue","getDefaultValue","getInitialState","isKeyDownOperationPermitted","metaKey","ctrlKey","altKey","HTMLInputElement","selectionStart","selectionEnd","getA11yRemovalMessage","removedSelectedItem","initialSelectedItems","defaultSelectedItems","initialActiveIndex","defaultActiveIndex","onActiveIndexChange","onSelectedItemsChange","keyNavigationNext","keyNavigationPrevious","validatePropTypes","SelectedItemClick","SelectedItemKeyDownDelete","SelectedItemKeyDownBackspace","SelectedItemKeyDownNavigationNext","SelectedItemKeyDownNavigationPrevious","DropdownKeyDownNavigationPrevious","DropdownKeyDownBackspace","DropdownClick","FunctionAddSelectedItem","FunctionRemoveSelectedItem","FunctionSetSelectedItems","FunctionSetActiveIndex","downshiftMultipleSelectionReducer","newActiveIndex","selectedItemIndex","newSelectedItems","useMultipleSelection","dropdownRef","previousSelectedItemsRef","selectedItemRefs","find","activeSelectedItem","selectedItemKeyDownHandlers","Delete","Backspace","dropdownKeyDownHandlers","getSelectedItemProps","selectedItemHandleClick","selectedItemHandleKeyDown","selectedItemNode","getDropdownProps","preventKeyAction","dropdownHandleKeyDown","dropdownHandleClick","dropdownNode","addSelectedItem","removeSelectedItem","setSelectedItems","setActiveIndex","default"],"sources":["/Users/sbmac/Downloads/ramp-fe-challenge-solved/node_modules/downshift/dist/downshift.esm.js"],"sourcesContent":["import PropTypes from 'prop-types';\nimport { Component, cloneElement, useRef, useEffect, useCallback, useLayoutEffect, useReducer, useMemo } from 'react';\nimport { isForwardRef } from 'react-is';\nimport computeScrollIntoView from 'compute-scroll-into-view';\nimport { __assign } from 'tslib';\n\nlet idCounter = 0;\n/**\n * Accepts a parameter and returns it if it's a function\n * or a noop function if it's not. This allows us to\n * accept a callback, but not worry about it if it's not\n * passed.\n * @param {Function} cb the callback\n * @return {Function} a function\n */\n\nfunction cbToCb(cb) {\n  return typeof cb === 'function' ? cb : noop;\n}\n\nfunction noop() {}\n/**\n * Scroll node into view if necessary\n * @param {HTMLElement} node the element that should scroll into view\n * @param {HTMLElement} menuNode the menu element of the component\n */\n\n\nfunction scrollIntoView(node, menuNode) {\n  if (!node) {\n    return;\n  }\n\n  const actions = computeScrollIntoView(node, {\n    boundary: menuNode,\n    block: 'nearest',\n    scrollMode: 'if-needed'\n  });\n  actions.forEach(_ref => {\n    let {\n      el,\n      top,\n      left\n    } = _ref;\n    el.scrollTop = top;\n    el.scrollLeft = left;\n  });\n}\n/**\n * @param {HTMLElement} parent the parent node\n * @param {HTMLElement} child the child node\n * @param {Window} environment The window context where downshift renders.\n * @return {Boolean} whether the parent is the child or the child is in the parent\n */\n\n\nfunction isOrContainsNode(parent, child, environment) {\n  const result = parent === child || child instanceof environment.Node && parent.contains && parent.contains(child);\n  return result;\n}\n/**\n * Simple debounce implementation. Will call the given\n * function once after the time given has passed since\n * it was last called.\n * @param {Function} fn the function to call after the time\n * @param {Number} time the time to wait\n * @return {Function} the debounced function\n */\n\n\nfunction debounce(fn, time) {\n  let timeoutId;\n\n  function cancel() {\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n    }\n  }\n\n  function wrapper() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    cancel();\n    timeoutId = setTimeout(() => {\n      timeoutId = null;\n      fn(...args);\n    }, time);\n  }\n\n  wrapper.cancel = cancel;\n  return wrapper;\n}\n/**\n * This is intended to be used to compose event handlers.\n * They are executed in order until one of them sets\n * `event.preventDownshiftDefault = true`.\n * @param {...Function} fns the event handler functions\n * @return {Function} the event handler to add to an element\n */\n\n\nfunction callAllEventHandlers() {\n  for (var _len2 = arguments.length, fns = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    fns[_key2] = arguments[_key2];\n  }\n\n  return function (event) {\n    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n      args[_key3 - 1] = arguments[_key3];\n    }\n\n    return fns.some(fn => {\n      if (fn) {\n        fn(event, ...args);\n      }\n\n      return event.preventDownshiftDefault || event.hasOwnProperty('nativeEvent') && event.nativeEvent.preventDownshiftDefault;\n    });\n  };\n}\n\nfunction handleRefs() {\n  for (var _len4 = arguments.length, refs = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n    refs[_key4] = arguments[_key4];\n  }\n\n  return node => {\n    refs.forEach(ref => {\n      if (typeof ref === 'function') {\n        ref(node);\n      } else if (ref) {\n        ref.current = node;\n      }\n    });\n  };\n}\n/**\n * This generates a unique ID for an instance of Downshift\n * @return {String} the unique ID\n */\n\n\nfunction generateId() {\n  return String(idCounter++);\n}\n/**\n * Resets idCounter to 0. Used for SSR.\n */\n\n\nfunction resetIdCounter() {\n  idCounter = 0;\n}\n/**\n * Default implementation for status message. Only added when menu is open.\n * Will specify if there are results in the list, and if so, how many,\n * and what keys are relevant.\n *\n * @param {Object} param the downshift state and other relevant properties\n * @return {String} the a11y status message\n */\n\n\nfunction getA11yStatusMessage$1(_ref2) {\n  let {\n    isOpen,\n    resultCount,\n    previousResultCount\n  } = _ref2;\n\n  if (!isOpen) {\n    return '';\n  }\n\n  if (!resultCount) {\n    return 'No results are available.';\n  }\n\n  if (resultCount !== previousResultCount) {\n    return `${resultCount} result${resultCount === 1 ? ' is' : 's are'} available, use up and down arrow keys to navigate. Press Enter key to select.`;\n  }\n\n  return '';\n}\n/**\n * Takes an argument and if it's an array, returns the first item in the array\n * otherwise returns the argument\n * @param {*} arg the maybe-array\n * @param {*} defaultValue the value if arg is falsey not defined\n * @return {*} the arg or it's first item\n */\n\n\nfunction unwrapArray(arg, defaultValue) {\n  arg = Array.isArray(arg) ?\n  /* istanbul ignore next (preact) */\n  arg[0] : arg;\n\n  if (!arg && defaultValue) {\n    return defaultValue;\n  } else {\n    return arg;\n  }\n}\n/**\n * @param {Object} element (P)react element\n * @return {Boolean} whether it's a DOM element\n */\n\n\nfunction isDOMElement(element) {\n\n\n  return typeof element.type === 'string';\n}\n/**\n * @param {Object} element (P)react element\n * @return {Object} the props\n */\n\n\nfunction getElementProps(element) {\n\n  return element.props;\n}\n/**\n * Throws a helpful error message for required properties. Useful\n * to be used as a default in destructuring or object params.\n * @param {String} fnName the function name\n * @param {String} propName the prop name\n */\n\n\nfunction requiredProp(fnName, propName) {\n  // eslint-disable-next-line no-console\n  console.error(`The property \"${propName}\" is required in \"${fnName}\"`);\n}\n\nconst stateKeys = ['highlightedIndex', 'inputValue', 'isOpen', 'selectedItem', 'type'];\n/**\n * @param {Object} state the state object\n * @return {Object} state that is relevant to downshift\n */\n\nfunction pickState(state) {\n  if (state === void 0) {\n    state = {};\n  }\n\n  const result = {};\n  stateKeys.forEach(k => {\n    if (state.hasOwnProperty(k)) {\n      result[k] = state[k];\n    }\n  });\n  return result;\n}\n/**\n * This will perform a shallow merge of the given state object\n * with the state coming from props\n * (for the controlled component scenario)\n * This is used in state updater functions so they're referencing\n * the right state regardless of where it comes from.\n *\n * @param {Object} state The state of the component/hook.\n * @param {Object} props The props that may contain controlled values.\n * @returns {Object} The merged controlled state.\n */\n\n\nfunction getState(state, props) {\n  return Object.keys(state).reduce((prevState, key) => {\n    prevState[key] = isControlledProp(props, key) ? props[key] : state[key];\n    return prevState;\n  }, {});\n}\n/**\n * This determines whether a prop is a \"controlled prop\" meaning it is\n * state which is controlled by the outside of this component rather\n * than within this component.\n *\n * @param {Object} props The props that may contain controlled values.\n * @param {String} key the key to check\n * @return {Boolean} whether it is a controlled controlled prop\n */\n\n\nfunction isControlledProp(props, key) {\n  return props[key] !== undefined;\n}\n/**\n * Normalizes the 'key' property of a KeyboardEvent in IE/Edge\n * @param {Object} event a keyboardEvent object\n * @return {String} keyboard key\n */\n\n\nfunction normalizeArrowKey(event) {\n  const {\n    key,\n    keyCode\n  } = event;\n  /* istanbul ignore next (ie) */\n\n  if (keyCode >= 37 && keyCode <= 40 && key.indexOf('Arrow') !== 0) {\n    return `Arrow${key}`;\n  }\n\n  return key;\n}\n/**\n * Simple check if the value passed is object literal\n * @param {*} obj any things\n * @return {Boolean} whether it's object literal\n */\n\n\nfunction isPlainObject(obj) {\n  return Object.prototype.toString.call(obj) === '[object Object]';\n}\n/**\n * Returns the new index in the list, in a circular way. If next value is out of bonds from the total,\n * it will wrap to either 0 or itemCount - 1.\n *\n * @param {number} moveAmount Number of positions to move. Negative to move backwards, positive forwards.\n * @param {number} baseIndex The initial position to move from.\n * @param {number} itemCount The total number of items.\n * @param {Function} getItemNodeFromIndex Used to check if item is disabled.\n * @param {boolean} circular Specify if navigation is circular. Default is true.\n * @returns {number} The new index after the move.\n */\n\n\nfunction getNextWrappingIndex(moveAmount, baseIndex, itemCount, getItemNodeFromIndex, circular) {\n  if (circular === void 0) {\n    circular = true;\n  }\n\n  if (itemCount === 0) {\n    return -1;\n  }\n\n  const itemsLastIndex = itemCount - 1;\n\n  if (typeof baseIndex !== 'number' || baseIndex < 0 || baseIndex >= itemCount) {\n    baseIndex = moveAmount > 0 ? -1 : itemsLastIndex + 1;\n  }\n\n  let newIndex = baseIndex + moveAmount;\n\n  if (newIndex < 0) {\n    newIndex = circular ? itemsLastIndex : 0;\n  } else if (newIndex > itemsLastIndex) {\n    newIndex = circular ? 0 : itemsLastIndex;\n  }\n\n  const nonDisabledNewIndex = getNextNonDisabledIndex(moveAmount, newIndex, itemCount, getItemNodeFromIndex, circular);\n\n  if (nonDisabledNewIndex === -1) {\n    return baseIndex >= itemCount ? -1 : baseIndex;\n  }\n\n  return nonDisabledNewIndex;\n}\n/**\n * Returns the next index in the list of an item that is not disabled.\n *\n * @param {number} moveAmount Number of positions to move. Negative to move backwards, positive forwards.\n * @param {number} baseIndex The initial position to move from.\n * @param {number} itemCount The total number of items.\n * @param {Function} getItemNodeFromIndex Used to check if item is disabled.\n * @param {boolean} circular Specify if navigation is circular. Default is true.\n * @returns {number} The new index. Returns baseIndex if item is not disabled. Returns next non-disabled item otherwise. If no non-disabled found it will return -1.\n */\n\n\nfunction getNextNonDisabledIndex(moveAmount, baseIndex, itemCount, getItemNodeFromIndex, circular) {\n  const currentElementNode = getItemNodeFromIndex(baseIndex);\n\n  if (!currentElementNode || !currentElementNode.hasAttribute('disabled')) {\n    return baseIndex;\n  }\n\n  if (moveAmount > 0) {\n    for (let index = baseIndex + 1; index < itemCount; index++) {\n      if (!getItemNodeFromIndex(index).hasAttribute('disabled')) {\n        return index;\n      }\n    }\n  } else {\n    for (let index = baseIndex - 1; index >= 0; index--) {\n      if (!getItemNodeFromIndex(index).hasAttribute('disabled')) {\n        return index;\n      }\n    }\n  }\n\n  if (circular) {\n    return moveAmount > 0 ? getNextNonDisabledIndex(1, 0, itemCount, getItemNodeFromIndex, false) : getNextNonDisabledIndex(-1, itemCount - 1, itemCount, getItemNodeFromIndex, false);\n  }\n\n  return -1;\n}\n/**\n * Checks if event target is within the downshift elements.\n *\n * @param {EventTarget} target Target to check.\n * @param {HTMLElement[]} downshiftElements The elements that form downshift (list, toggle button etc).\n * @param {Window} environment The window context where downshift renders.\n * @param {boolean} checkActiveElement Whether to also check activeElement.\n *\n * @returns {boolean} Whether or not the target is within downshift elements.\n */\n\n\nfunction targetWithinDownshift(target, downshiftElements, environment, checkActiveElement) {\n  if (checkActiveElement === void 0) {\n    checkActiveElement = true;\n  }\n\n  return downshiftElements.some(contextNode => contextNode && (isOrContainsNode(contextNode, target, environment) || checkActiveElement && isOrContainsNode(contextNode, environment.document.activeElement, environment)));\n} // eslint-disable-next-line import/no-mutable-exports\n\n\nlet validateControlledUnchanged = noop;\n/* istanbul ignore next */\n\nif (process.env.NODE_ENV !== 'production') {\n  validateControlledUnchanged = (state, prevProps, nextProps) => {\n    const warningDescription = `This prop should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled Downshift element for the lifetime of the component. More info: https://github.com/downshift-js/downshift#control-props`;\n    Object.keys(state).forEach(propKey => {\n      if (prevProps[propKey] !== undefined && nextProps[propKey] === undefined) {\n        // eslint-disable-next-line no-console\n        console.error(`downshift: A component has changed the controlled prop \"${propKey}\" to be uncontrolled. ${warningDescription}`);\n      } else if (prevProps[propKey] === undefined && nextProps[propKey] !== undefined) {\n        // eslint-disable-next-line no-console\n        console.error(`downshift: A component has changed the uncontrolled prop \"${propKey}\" to be controlled. ${warningDescription}`);\n      }\n    });\n  };\n}\n\nconst cleanupStatus = debounce(documentProp => {\n  getStatusDiv(documentProp).textContent = '';\n}, 500);\n/**\n * @param {String} status the status message\n * @param {Object} documentProp document passed by the user.\n */\n\nfunction setStatus(status, documentProp) {\n  const div = getStatusDiv(documentProp);\n\n  if (!status) {\n    return;\n  }\n\n  div.textContent = status;\n  cleanupStatus(documentProp);\n}\n/**\n * Get the status node or create it if it does not already exist.\n * @param {Object} documentProp document passed by the user.\n * @return {HTMLElement} the status node.\n */\n\n\nfunction getStatusDiv(documentProp) {\n  if (documentProp === void 0) {\n    documentProp = document;\n  }\n\n  let statusDiv = documentProp.getElementById('a11y-status-message');\n\n  if (statusDiv) {\n    return statusDiv;\n  }\n\n  statusDiv = documentProp.createElement('div');\n  statusDiv.setAttribute('id', 'a11y-status-message');\n  statusDiv.setAttribute('role', 'status');\n  statusDiv.setAttribute('aria-live', 'polite');\n  statusDiv.setAttribute('aria-relevant', 'additions text');\n  Object.assign(statusDiv.style, {\n    border: '0',\n    clip: 'rect(0 0 0 0)',\n    height: '1px',\n    margin: '-1px',\n    overflow: 'hidden',\n    padding: '0',\n    position: 'absolute',\n    width: '1px'\n  });\n  documentProp.body.appendChild(statusDiv);\n  return statusDiv;\n}\n\nconst unknown = process.env.NODE_ENV !== \"production\" ? '__autocomplete_unknown__' : 0;\nconst mouseUp = process.env.NODE_ENV !== \"production\" ? '__autocomplete_mouseup__' : 1;\nconst itemMouseEnter = process.env.NODE_ENV !== \"production\" ? '__autocomplete_item_mouseenter__' : 2;\nconst keyDownArrowUp = process.env.NODE_ENV !== \"production\" ? '__autocomplete_keydown_arrow_up__' : 3;\nconst keyDownArrowDown = process.env.NODE_ENV !== \"production\" ? '__autocomplete_keydown_arrow_down__' : 4;\nconst keyDownEscape = process.env.NODE_ENV !== \"production\" ? '__autocomplete_keydown_escape__' : 5;\nconst keyDownEnter = process.env.NODE_ENV !== \"production\" ? '__autocomplete_keydown_enter__' : 6;\nconst keyDownHome = process.env.NODE_ENV !== \"production\" ? '__autocomplete_keydown_home__' : 7;\nconst keyDownEnd = process.env.NODE_ENV !== \"production\" ? '__autocomplete_keydown_end__' : 8;\nconst clickItem = process.env.NODE_ENV !== \"production\" ? '__autocomplete_click_item__' : 9;\nconst blurInput = process.env.NODE_ENV !== \"production\" ? '__autocomplete_blur_input__' : 10;\nconst changeInput = process.env.NODE_ENV !== \"production\" ? '__autocomplete_change_input__' : 11;\nconst keyDownSpaceButton = process.env.NODE_ENV !== \"production\" ? '__autocomplete_keydown_space_button__' : 12;\nconst clickButton = process.env.NODE_ENV !== \"production\" ? '__autocomplete_click_button__' : 13;\nconst blurButton = process.env.NODE_ENV !== \"production\" ? '__autocomplete_blur_button__' : 14;\nconst controlledPropUpdatedSelectedItem = process.env.NODE_ENV !== \"production\" ? '__autocomplete_controlled_prop_updated_selected_item__' : 15;\nconst touchEnd = process.env.NODE_ENV !== \"production\" ? '__autocomplete_touchend__' : 16;\n\nvar stateChangeTypes$3 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  unknown: unknown,\n  mouseUp: mouseUp,\n  itemMouseEnter: itemMouseEnter,\n  keyDownArrowUp: keyDownArrowUp,\n  keyDownArrowDown: keyDownArrowDown,\n  keyDownEscape: keyDownEscape,\n  keyDownEnter: keyDownEnter,\n  keyDownHome: keyDownHome,\n  keyDownEnd: keyDownEnd,\n  clickItem: clickItem,\n  blurInput: blurInput,\n  changeInput: changeInput,\n  keyDownSpaceButton: keyDownSpaceButton,\n  clickButton: clickButton,\n  blurButton: blurButton,\n  controlledPropUpdatedSelectedItem: controlledPropUpdatedSelectedItem,\n  touchEnd: touchEnd\n});\n\n/* eslint camelcase:0 */\n\nconst Downshift = /*#__PURE__*/(() => {\n  class Downshift extends Component {\n    constructor(_props) {\n      var _this;\n\n      super(_props);\n      _this = this;\n      this.id = this.props.id || `downshift-${generateId()}`;\n      this.menuId = this.props.menuId || `${this.id}-menu`;\n      this.labelId = this.props.labelId || `${this.id}-label`;\n      this.inputId = this.props.inputId || `${this.id}-input`;\n\n      this.getItemId = this.props.getItemId || (index => `${this.id}-item-${index}`);\n\n      this.input = null;\n      this.items = [];\n      this.itemCount = null;\n      this.previousResultCount = 0;\n      this.timeoutIds = [];\n\n      this.internalSetTimeout = (fn, time) => {\n        const id = setTimeout(() => {\n          this.timeoutIds = this.timeoutIds.filter(i => i !== id);\n          fn();\n        }, time);\n        this.timeoutIds.push(id);\n      };\n\n      this.setItemCount = count => {\n        this.itemCount = count;\n      };\n\n      this.unsetItemCount = () => {\n        this.itemCount = null;\n      };\n\n      this.setHighlightedIndex = function (highlightedIndex, otherStateToSet) {\n        if (highlightedIndex === void 0) {\n          highlightedIndex = _this.props.defaultHighlightedIndex;\n        }\n\n        if (otherStateToSet === void 0) {\n          otherStateToSet = {};\n        }\n\n        otherStateToSet = pickState(otherStateToSet);\n\n        _this.internalSetState({\n          highlightedIndex,\n          ...otherStateToSet\n        });\n      };\n\n      this.clearSelection = cb => {\n        this.internalSetState({\n          selectedItem: null,\n          inputValue: '',\n          highlightedIndex: this.props.defaultHighlightedIndex,\n          isOpen: this.props.defaultIsOpen\n        }, cb);\n      };\n\n      this.selectItem = (item, otherStateToSet, cb) => {\n        otherStateToSet = pickState(otherStateToSet);\n        this.internalSetState({\n          isOpen: this.props.defaultIsOpen,\n          highlightedIndex: this.props.defaultHighlightedIndex,\n          selectedItem: item,\n          inputValue: this.props.itemToString(item),\n          ...otherStateToSet\n        }, cb);\n      };\n\n      this.selectItemAtIndex = (itemIndex, otherStateToSet, cb) => {\n        const item = this.items[itemIndex];\n\n        if (item == null) {\n          return;\n        }\n\n        this.selectItem(item, otherStateToSet, cb);\n      };\n\n      this.selectHighlightedItem = (otherStateToSet, cb) => {\n        return this.selectItemAtIndex(this.getState().highlightedIndex, otherStateToSet, cb);\n      };\n\n      this.internalSetState = (stateToSet, cb) => {\n        let isItemSelected, onChangeArg;\n        const onStateChangeArg = {};\n        const isStateToSetFunction = typeof stateToSet === 'function'; // we want to call `onInputValueChange` before the `setState` call\n        // so someone controlling the `inputValue` state gets notified of\n        // the input change as soon as possible. This avoids issues with\n        // preserving the cursor position.\n        // See https://github.com/downshift-js/downshift/issues/217 for more info.\n\n        if (!isStateToSetFunction && stateToSet.hasOwnProperty('inputValue')) {\n          this.props.onInputValueChange(stateToSet.inputValue, { ...this.getStateAndHelpers(),\n            ...stateToSet\n          });\n        }\n\n        return this.setState(state => {\n          state = this.getState(state);\n          let newStateToSet = isStateToSetFunction ? stateToSet(state) : stateToSet; // Your own function that could modify the state that will be set.\n\n          newStateToSet = this.props.stateReducer(state, newStateToSet); // checks if an item is selected, regardless of if it's different from\n          // what was selected before\n          // used to determine if onSelect and onChange callbacks should be called\n\n          isItemSelected = newStateToSet.hasOwnProperty('selectedItem'); // this keeps track of the object we want to call with setState\n\n          const nextState = {}; // this is just used to tell whether the state changed\n          // and we're trying to update that state. OR if the selection has changed and we're\n          // trying to update the selection\n\n          if (isItemSelected && newStateToSet.selectedItem !== state.selectedItem) {\n            onChangeArg = newStateToSet.selectedItem;\n          }\n\n          newStateToSet.type = newStateToSet.type || unknown;\n          Object.keys(newStateToSet).forEach(key => {\n            // onStateChangeArg should only have the state that is\n            // actually changing\n            if (state[key] !== newStateToSet[key]) {\n              onStateChangeArg[key] = newStateToSet[key];\n            } // the type is useful for the onStateChangeArg\n            // but we don't actually want to set it in internal state.\n            // this is an undocumented feature for now... Not all internalSetState\n            // calls support it and I'm not certain we want them to yet.\n            // But it enables users controlling the isOpen state to know when\n            // the isOpen state changes due to mouseup events which is quite handy.\n\n\n            if (key === 'type') {\n              return;\n            }\n\n            newStateToSet[key]; // if it's coming from props, then we don't care to set it internally\n\n            if (!isControlledProp(this.props, key)) {\n              nextState[key] = newStateToSet[key];\n            }\n          }); // if stateToSet is a function, then we weren't able to call onInputValueChange\n          // earlier, so we'll call it now that we know what the inputValue state will be.\n\n          if (isStateToSetFunction && newStateToSet.hasOwnProperty('inputValue')) {\n            this.props.onInputValueChange(newStateToSet.inputValue, { ...this.getStateAndHelpers(),\n              ...newStateToSet\n            });\n          }\n\n          return nextState;\n        }, () => {\n          // call the provided callback if it's a function\n          cbToCb(cb)(); // only call the onStateChange and onChange callbacks if\n          // we have relevant information to pass them.\n\n          const hasMoreStateThanType = Object.keys(onStateChangeArg).length > 1;\n\n          if (hasMoreStateThanType) {\n            this.props.onStateChange(onStateChangeArg, this.getStateAndHelpers());\n          }\n\n          if (isItemSelected) {\n            this.props.onSelect(stateToSet.selectedItem, this.getStateAndHelpers());\n          }\n\n          if (onChangeArg !== undefined) {\n            this.props.onChange(onChangeArg, this.getStateAndHelpers());\n          } // this is currently undocumented and therefore subject to change\n          // We'll try to not break it, but just be warned.\n\n\n          this.props.onUserAction(onStateChangeArg, this.getStateAndHelpers());\n        });\n      };\n\n      this.rootRef = node => this._rootNode = node;\n\n      this.getRootProps = function (_temp, _temp2) {\n        let {\n          refKey = 'ref',\n          ref,\n          ...rest\n        } = _temp === void 0 ? {} : _temp;\n        let {\n          suppressRefError = false\n        } = _temp2 === void 0 ? {} : _temp2;\n        // this is used in the render to know whether the user has called getRootProps.\n        // It uses that to know whether to apply the props automatically\n        _this.getRootProps.called = true;\n        _this.getRootProps.refKey = refKey;\n        _this.getRootProps.suppressRefError = suppressRefError;\n\n        const {\n          isOpen\n        } = _this.getState();\n\n        return {\n          [refKey]: handleRefs(ref, _this.rootRef),\n          role: 'combobox',\n          'aria-expanded': isOpen,\n          'aria-haspopup': 'listbox',\n          'aria-owns': isOpen ? _this.menuId : null,\n          'aria-labelledby': _this.labelId,\n          ...rest\n        };\n      };\n\n      this.keyDownHandlers = {\n        ArrowDown(event) {\n          event.preventDefault();\n\n          if (this.getState().isOpen) {\n            const amount = event.shiftKey ? 5 : 1;\n            this.moveHighlightedIndex(amount, {\n              type: keyDownArrowDown\n            });\n          } else {\n            this.internalSetState({\n              isOpen: true,\n              type: keyDownArrowDown\n            }, () => {\n              const itemCount = this.getItemCount();\n\n              if (itemCount > 0) {\n                const {\n                  highlightedIndex\n                } = this.getState();\n                const nextHighlightedIndex = getNextWrappingIndex(1, highlightedIndex, itemCount, index => this.getItemNodeFromIndex(index));\n                this.setHighlightedIndex(nextHighlightedIndex, {\n                  type: keyDownArrowDown\n                });\n              }\n            });\n          }\n        },\n\n        ArrowUp(event) {\n          event.preventDefault();\n\n          if (this.getState().isOpen) {\n            const amount = event.shiftKey ? -5 : -1;\n            this.moveHighlightedIndex(amount, {\n              type: keyDownArrowUp\n            });\n          } else {\n            this.internalSetState({\n              isOpen: true,\n              type: keyDownArrowUp\n            }, () => {\n              const itemCount = this.getItemCount();\n\n              if (itemCount > 0) {\n                const {\n                  highlightedIndex\n                } = this.getState();\n                const nextHighlightedIndex = getNextWrappingIndex(-1, highlightedIndex, itemCount, index => this.getItemNodeFromIndex(index));\n                this.setHighlightedIndex(nextHighlightedIndex, {\n                  type: keyDownArrowUp\n                });\n              }\n            });\n          }\n        },\n\n        Enter(event) {\n          if (event.which === 229) {\n            return;\n          }\n\n          const {\n            isOpen,\n            highlightedIndex\n          } = this.getState();\n\n          if (isOpen && highlightedIndex != null) {\n            event.preventDefault();\n            const item = this.items[highlightedIndex];\n            const itemNode = this.getItemNodeFromIndex(highlightedIndex);\n\n            if (item == null || itemNode && itemNode.hasAttribute('disabled')) {\n              return;\n            }\n\n            this.selectHighlightedItem({\n              type: keyDownEnter\n            });\n          }\n        },\n\n        Escape(event) {\n          event.preventDefault();\n          this.reset({\n            type: keyDownEscape,\n            ...(!this.state.isOpen && {\n              selectedItem: null,\n              inputValue: ''\n            })\n          });\n        }\n\n      };\n      this.buttonKeyDownHandlers = { ...this.keyDownHandlers,\n\n        ' '(event) {\n          event.preventDefault();\n          this.toggleMenu({\n            type: keyDownSpaceButton\n          });\n        }\n\n      };\n      this.inputKeyDownHandlers = { ...this.keyDownHandlers,\n\n        Home(event) {\n          const {\n            isOpen\n          } = this.getState();\n\n          if (!isOpen) {\n            return;\n          }\n\n          event.preventDefault();\n          const itemCount = this.getItemCount();\n\n          if (itemCount <= 0 || !isOpen) {\n            return;\n          } // get next non-disabled starting downwards from 0 if that's disabled.\n\n\n          const newHighlightedIndex = getNextNonDisabledIndex(1, 0, itemCount, index => this.getItemNodeFromIndex(index), false);\n          this.setHighlightedIndex(newHighlightedIndex, {\n            type: keyDownHome\n          });\n        },\n\n        End(event) {\n          const {\n            isOpen\n          } = this.getState();\n\n          if (!isOpen) {\n            return;\n          }\n\n          event.preventDefault();\n          const itemCount = this.getItemCount();\n\n          if (itemCount <= 0 || !isOpen) {\n            return;\n          } // get next non-disabled starting upwards from last index if that's disabled.\n\n\n          const newHighlightedIndex = getNextNonDisabledIndex(-1, itemCount - 1, itemCount, index => this.getItemNodeFromIndex(index), false);\n          this.setHighlightedIndex(newHighlightedIndex, {\n            type: keyDownEnd\n          });\n        }\n\n      };\n\n      this.getToggleButtonProps = function (_temp3) {\n        let {\n          onClick,\n          onPress,\n          onKeyDown,\n          onKeyUp,\n          onBlur,\n          ...rest\n        } = _temp3 === void 0 ? {} : _temp3;\n\n        const {\n          isOpen\n        } = _this.getState();\n\n        const enabledEventHandlers = {\n          onClick: callAllEventHandlers(onClick, _this.buttonHandleClick),\n          onKeyDown: callAllEventHandlers(onKeyDown, _this.buttonHandleKeyDown),\n          onKeyUp: callAllEventHandlers(onKeyUp, _this.buttonHandleKeyUp),\n          onBlur: callAllEventHandlers(onBlur, _this.buttonHandleBlur)\n        };\n        const eventHandlers = rest.disabled ? {} : enabledEventHandlers;\n        return {\n          type: 'button',\n          role: 'button',\n          'aria-label': isOpen ? 'close menu' : 'open menu',\n          'aria-haspopup': true,\n          'data-toggle': true,\n          ...eventHandlers,\n          ...rest\n        };\n      };\n\n      this.buttonHandleKeyUp = event => {\n        // Prevent click event from emitting in Firefox\n        event.preventDefault();\n      };\n\n      this.buttonHandleKeyDown = event => {\n        const key = normalizeArrowKey(event);\n\n        if (this.buttonKeyDownHandlers[key]) {\n          this.buttonKeyDownHandlers[key].call(this, event);\n        }\n      };\n\n      this.buttonHandleClick = event => {\n        event.preventDefault(); // handle odd case for Safari and Firefox which\n        // don't give the button the focus properly.\n\n        /* istanbul ignore if (can't reasonably test this) */\n\n        if (this.props.environment.document.activeElement === this.props.environment.document.body) {\n          event.target.focus();\n        } // to simplify testing components that use downshift, we'll not wrap this in a setTimeout\n        // if the NODE_ENV is test. With the proper build system, this should be dead code eliminated\n        // when building for production and should therefore have no impact on production code.\n\n\n        if (process.env.NODE_ENV === 'test') {\n          this.toggleMenu({\n            type: clickButton\n          });\n        } else {\n          // Ensure that toggle of menu occurs after the potential blur event in iOS\n          this.internalSetTimeout(() => this.toggleMenu({\n            type: clickButton\n          }));\n        }\n      };\n\n      this.buttonHandleBlur = event => {\n        const blurTarget = event.target; // Save blur target for comparison with activeElement later\n        // Need setTimeout, so that when the user presses Tab, the activeElement is the next focused element, not body element\n\n        this.internalSetTimeout(() => {\n          if (!this.isMouseDown && (this.props.environment.document.activeElement == null || this.props.environment.document.activeElement.id !== this.inputId) && this.props.environment.document.activeElement !== blurTarget // Do nothing if we refocus the same element again (to solve issue in Safari on iOS)\n          ) {\n            this.reset({\n              type: blurButton\n            });\n          }\n        });\n      };\n\n      this.getLabelProps = props => {\n        return {\n          htmlFor: this.inputId,\n          id: this.labelId,\n          ...props\n        };\n      };\n\n      this.getInputProps = function (_temp4) {\n        let {\n          onKeyDown,\n          onBlur,\n          onChange,\n          onInput,\n          onChangeText,\n          ...rest\n        } = _temp4 === void 0 ? {} : _temp4;\n        let onChangeKey;\n        let eventHandlers = {};\n        /* istanbul ignore next (preact) */\n\n        {\n          onChangeKey = 'onChange';\n        }\n\n        const {\n          inputValue,\n          isOpen,\n          highlightedIndex\n        } = _this.getState();\n\n        if (!rest.disabled) {\n          eventHandlers = {\n            [onChangeKey]: callAllEventHandlers(onChange, onInput, _this.inputHandleChange),\n            onKeyDown: callAllEventHandlers(onKeyDown, _this.inputHandleKeyDown),\n            onBlur: callAllEventHandlers(onBlur, _this.inputHandleBlur)\n          };\n        }\n\n        return {\n          'aria-autocomplete': 'list',\n          'aria-activedescendant': isOpen && typeof highlightedIndex === 'number' && highlightedIndex >= 0 ? _this.getItemId(highlightedIndex) : null,\n          'aria-controls': isOpen ? _this.menuId : null,\n          'aria-labelledby': _this.labelId,\n          // https://developer.mozilla.org/en-US/docs/Web/Security/Securing_your_site/Turning_off_form_autocompletion\n          // revert back since autocomplete=\"nope\" is ignored on latest Chrome and Opera\n          autoComplete: 'off',\n          value: inputValue,\n          id: _this.inputId,\n          ...eventHandlers,\n          ...rest\n        };\n      };\n\n      this.inputHandleKeyDown = event => {\n        const key = normalizeArrowKey(event);\n\n        if (key && this.inputKeyDownHandlers[key]) {\n          this.inputKeyDownHandlers[key].call(this, event);\n        }\n      };\n\n      this.inputHandleChange = event => {\n        this.internalSetState({\n          type: changeInput,\n          isOpen: true,\n          inputValue: event.target.value,\n          highlightedIndex: this.props.defaultHighlightedIndex\n        });\n      };\n\n      this.inputHandleBlur = () => {\n        // Need setTimeout, so that when the user presses Tab, the activeElement is the next focused element, not the body element\n        this.internalSetTimeout(() => {\n          const downshiftButtonIsActive = this.props.environment.document && !!this.props.environment.document.activeElement && !!this.props.environment.document.activeElement.dataset && this.props.environment.document.activeElement.dataset.toggle && this._rootNode && this._rootNode.contains(this.props.environment.document.activeElement);\n\n          if (!this.isMouseDown && !downshiftButtonIsActive) {\n            this.reset({\n              type: blurInput\n            });\n          }\n        });\n      };\n\n      this.menuRef = node => {\n        this._menuNode = node;\n      };\n\n      this.getMenuProps = function (_temp5, _temp6) {\n        let {\n          refKey = 'ref',\n          ref,\n          ...props\n        } = _temp5 === void 0 ? {} : _temp5;\n        let {\n          suppressRefError = false\n        } = _temp6 === void 0 ? {} : _temp6;\n        _this.getMenuProps.called = true;\n        _this.getMenuProps.refKey = refKey;\n        _this.getMenuProps.suppressRefError = suppressRefError;\n        return {\n          [refKey]: handleRefs(ref, _this.menuRef),\n          role: 'listbox',\n          'aria-labelledby': props && props['aria-label'] ? null : _this.labelId,\n          id: _this.menuId,\n          ...props\n        };\n      };\n\n      this.getItemProps = function (_temp7) {\n        let {\n          onMouseMove,\n          onMouseDown,\n          onClick,\n          onPress,\n          index,\n          item = process.env.NODE_ENV === 'production' ?\n          /* istanbul ignore next */\n          undefined : requiredProp('getItemProps', 'item'),\n          ...rest\n        } = _temp7 === void 0 ? {} : _temp7;\n\n        if (index === undefined) {\n          _this.items.push(item);\n\n          index = _this.items.indexOf(item);\n        } else {\n          _this.items[index] = item;\n        }\n\n        const onSelectKey = 'onClick';\n        const customClickHandler = onClick;\n        const enabledEventHandlers = {\n          // onMouseMove is used over onMouseEnter here. onMouseMove\n          // is only triggered on actual mouse movement while onMouseEnter\n          // can fire on DOM changes, interrupting keyboard navigation\n          onMouseMove: callAllEventHandlers(onMouseMove, () => {\n            if (index === _this.getState().highlightedIndex) {\n              return;\n            }\n\n            _this.setHighlightedIndex(index, {\n              type: itemMouseEnter\n            }); // We never want to manually scroll when changing state based\n            // on `onMouseMove` because we will be moving the element out\n            // from under the user which is currently scrolling/moving the\n            // cursor\n\n\n            _this.avoidScrolling = true;\n\n            _this.internalSetTimeout(() => _this.avoidScrolling = false, 250);\n          }),\n          onMouseDown: callAllEventHandlers(onMouseDown, event => {\n            // This prevents the activeElement from being changed\n            // to the item so it can remain with the current activeElement\n            // which is a more common use case.\n            event.preventDefault();\n          }),\n          [onSelectKey]: callAllEventHandlers(customClickHandler, () => {\n            _this.selectItemAtIndex(index, {\n              type: clickItem\n            });\n          })\n        }; // Passing down the onMouseDown handler to prevent redirect\n        // of the activeElement if clicking on disabled items\n\n        const eventHandlers = rest.disabled ? {\n          onMouseDown: enabledEventHandlers.onMouseDown\n        } : enabledEventHandlers;\n        return {\n          id: _this.getItemId(index),\n          role: 'option',\n          'aria-selected': _this.getState().highlightedIndex === index,\n          ...eventHandlers,\n          ...rest\n        };\n      };\n\n      this.clearItems = () => {\n        this.items = [];\n      };\n\n      this.reset = function (otherStateToSet, cb) {\n        if (otherStateToSet === void 0) {\n          otherStateToSet = {};\n        }\n\n        otherStateToSet = pickState(otherStateToSet);\n\n        _this.internalSetState(_ref => {\n          let {\n            selectedItem\n          } = _ref;\n          return {\n            isOpen: _this.props.defaultIsOpen,\n            highlightedIndex: _this.props.defaultHighlightedIndex,\n            inputValue: _this.props.itemToString(selectedItem),\n            ...otherStateToSet\n          };\n        }, cb);\n      };\n\n      this.toggleMenu = function (otherStateToSet, cb) {\n        if (otherStateToSet === void 0) {\n          otherStateToSet = {};\n        }\n\n        otherStateToSet = pickState(otherStateToSet);\n\n        _this.internalSetState(_ref2 => {\n          let {\n            isOpen\n          } = _ref2;\n          return {\n            isOpen: !isOpen,\n            ...(isOpen && {\n              highlightedIndex: _this.props.defaultHighlightedIndex\n            }),\n            ...otherStateToSet\n          };\n        }, () => {\n          const {\n            isOpen,\n            highlightedIndex\n          } = _this.getState();\n\n          if (isOpen) {\n            if (_this.getItemCount() > 0 && typeof highlightedIndex === 'number') {\n              _this.setHighlightedIndex(highlightedIndex, otherStateToSet);\n            }\n          }\n\n          cbToCb(cb)();\n        });\n      };\n\n      this.openMenu = cb => {\n        this.internalSetState({\n          isOpen: true\n        }, cb);\n      };\n\n      this.closeMenu = cb => {\n        this.internalSetState({\n          isOpen: false\n        }, cb);\n      };\n\n      this.updateStatus = debounce(() => {\n        const state = this.getState();\n        const item = this.items[state.highlightedIndex];\n        const resultCount = this.getItemCount();\n        const status = this.props.getA11yStatusMessage({\n          itemToString: this.props.itemToString,\n          previousResultCount: this.previousResultCount,\n          resultCount,\n          highlightedItem: item,\n          ...state\n        });\n        this.previousResultCount = resultCount;\n        setStatus(status, this.props.environment.document);\n      }, 200);\n      // fancy destructuring + defaults + aliases\n      // this basically says each value of state should either be set to\n      // the initial value or the default value if the initial value is not provided\n      const {\n        defaultHighlightedIndex,\n        initialHighlightedIndex: _highlightedIndex = defaultHighlightedIndex,\n        defaultIsOpen,\n        initialIsOpen: _isOpen = defaultIsOpen,\n        initialInputValue: _inputValue = '',\n        initialSelectedItem: _selectedItem = null\n      } = this.props;\n\n      const _state = this.getState({\n        highlightedIndex: _highlightedIndex,\n        isOpen: _isOpen,\n        inputValue: _inputValue,\n        selectedItem: _selectedItem\n      });\n\n      if (_state.selectedItem != null && this.props.initialInputValue === undefined) {\n        _state.inputValue = this.props.itemToString(_state.selectedItem);\n      }\n\n      this.state = _state;\n    }\n\n    /**\n     * Clear all running timeouts\n     */\n    internalClearTimeouts() {\n      this.timeoutIds.forEach(id => {\n        clearTimeout(id);\n      });\n      this.timeoutIds = [];\n    }\n    /**\n     * Gets the state based on internal state or props\n     * If a state value is passed via props, then that\n     * is the value given, otherwise it's retrieved from\n     * stateToMerge\n     *\n     * @param {Object} stateToMerge defaults to this.state\n     * @return {Object} the state\n     */\n\n\n    getState(stateToMerge) {\n      if (stateToMerge === void 0) {\n        stateToMerge = this.state;\n      }\n\n      return getState(stateToMerge, this.props);\n    }\n\n    getItemCount() {\n      // things read better this way. They're in priority order:\n      // 1. `this.itemCount`\n      // 2. `this.props.itemCount`\n      // 3. `this.items.length`\n      let itemCount = this.items.length;\n\n      if (this.itemCount != null) {\n        itemCount = this.itemCount;\n      } else if (this.props.itemCount !== undefined) {\n        itemCount = this.props.itemCount;\n      }\n\n      return itemCount;\n    }\n\n    getItemNodeFromIndex(index) {\n      return this.props.environment.document.getElementById(this.getItemId(index));\n    }\n\n    scrollHighlightedItemIntoView() {\n      /* istanbul ignore else (react-native) */\n      {\n        const node = this.getItemNodeFromIndex(this.getState().highlightedIndex);\n        this.props.scrollIntoView(node, this._menuNode);\n      }\n    }\n\n    moveHighlightedIndex(amount, otherStateToSet) {\n      const itemCount = this.getItemCount();\n      const {\n        highlightedIndex\n      } = this.getState();\n\n      if (itemCount > 0) {\n        const nextHighlightedIndex = getNextWrappingIndex(amount, highlightedIndex, itemCount, index => this.getItemNodeFromIndex(index));\n        this.setHighlightedIndex(nextHighlightedIndex, otherStateToSet);\n      }\n    }\n\n    getStateAndHelpers() {\n      const {\n        highlightedIndex,\n        inputValue,\n        selectedItem,\n        isOpen\n      } = this.getState();\n      const {\n        itemToString\n      } = this.props;\n      const {\n        id\n      } = this;\n      const {\n        getRootProps,\n        getToggleButtonProps,\n        getLabelProps,\n        getMenuProps,\n        getInputProps,\n        getItemProps,\n        openMenu,\n        closeMenu,\n        toggleMenu,\n        selectItem,\n        selectItemAtIndex,\n        selectHighlightedItem,\n        setHighlightedIndex,\n        clearSelection,\n        clearItems,\n        reset,\n        setItemCount,\n        unsetItemCount,\n        internalSetState: setState\n      } = this;\n      return {\n        // prop getters\n        getRootProps,\n        getToggleButtonProps,\n        getLabelProps,\n        getMenuProps,\n        getInputProps,\n        getItemProps,\n        // actions\n        reset,\n        openMenu,\n        closeMenu,\n        toggleMenu,\n        selectItem,\n        selectItemAtIndex,\n        selectHighlightedItem,\n        setHighlightedIndex,\n        clearSelection,\n        clearItems,\n        setItemCount,\n        unsetItemCount,\n        setState,\n        // props\n        itemToString,\n        // derived\n        id,\n        // state\n        highlightedIndex,\n        inputValue,\n        isOpen,\n        selectedItem\n      };\n    } //////////////////////////// ROOT\n\n\n    componentDidMount() {\n      /* istanbul ignore if (react-native) */\n      if (process.env.NODE_ENV !== 'production' && !false && this.getMenuProps.called && !this.getMenuProps.suppressRefError) {\n        validateGetMenuPropsCalledCorrectly(this._menuNode, this.getMenuProps);\n      }\n      /* istanbul ignore if (react-native) */\n\n\n      {\n        // this.isMouseDown helps us track whether the mouse is currently held down.\n        // This is useful when the user clicks on an item in the list, but holds the mouse\n        // down long enough for the list to disappear (because the blur event fires on the input)\n        // this.isMouseDown is used in the blur handler on the input to determine whether the blur event should\n        // trigger hiding the menu.\n        const onMouseDown = () => {\n          this.isMouseDown = true;\n        };\n\n        const onMouseUp = event => {\n          this.isMouseDown = false; // if the target element or the activeElement is within a downshift node\n          // then we don't want to reset downshift\n\n          const contextWithinDownshift = targetWithinDownshift(event.target, [this._rootNode, this._menuNode], this.props.environment);\n\n          if (!contextWithinDownshift && this.getState().isOpen) {\n            this.reset({\n              type: mouseUp\n            }, () => this.props.onOuterClick(this.getStateAndHelpers()));\n          }\n        }; // Touching an element in iOS gives focus and hover states, but touching out of\n        // the element will remove hover, and persist the focus state, resulting in the\n        // blur event not being triggered.\n        // this.isTouchMove helps us track whether the user is tapping or swiping on a touch screen.\n        // If the user taps outside of Downshift, the component should be reset,\n        // but not if the user is swiping\n\n\n        const onTouchStart = () => {\n          this.isTouchMove = false;\n        };\n\n        const onTouchMove = () => {\n          this.isTouchMove = true;\n        };\n\n        const onTouchEnd = event => {\n          const contextWithinDownshift = targetWithinDownshift(event.target, [this._rootNode, this._menuNode], this.props.environment, false);\n\n          if (!this.isTouchMove && !contextWithinDownshift && this.getState().isOpen) {\n            this.reset({\n              type: touchEnd\n            }, () => this.props.onOuterClick(this.getStateAndHelpers()));\n          }\n        };\n\n        const {\n          environment\n        } = this.props;\n        environment.addEventListener('mousedown', onMouseDown);\n        environment.addEventListener('mouseup', onMouseUp);\n        environment.addEventListener('touchstart', onTouchStart);\n        environment.addEventListener('touchmove', onTouchMove);\n        environment.addEventListener('touchend', onTouchEnd);\n\n        this.cleanup = () => {\n          this.internalClearTimeouts();\n          this.updateStatus.cancel();\n          environment.removeEventListener('mousedown', onMouseDown);\n          environment.removeEventListener('mouseup', onMouseUp);\n          environment.removeEventListener('touchstart', onTouchStart);\n          environment.removeEventListener('touchmove', onTouchMove);\n          environment.removeEventListener('touchend', onTouchEnd);\n        };\n      }\n    }\n\n    shouldScroll(prevState, prevProps) {\n      const {\n        highlightedIndex: currentHighlightedIndex\n      } = this.props.highlightedIndex === undefined ? this.getState() : this.props;\n      const {\n        highlightedIndex: prevHighlightedIndex\n      } = prevProps.highlightedIndex === undefined ? prevState : prevProps;\n      const scrollWhenOpen = currentHighlightedIndex && this.getState().isOpen && !prevState.isOpen;\n      const scrollWhenNavigating = currentHighlightedIndex !== prevHighlightedIndex;\n      return scrollWhenOpen || scrollWhenNavigating;\n    }\n\n    componentDidUpdate(prevProps, prevState) {\n      if (process.env.NODE_ENV !== 'production') {\n        validateControlledUnchanged(this.state, prevProps, this.props);\n        /* istanbul ignore if (react-native) */\n\n        if (this.getMenuProps.called && !this.getMenuProps.suppressRefError) {\n          validateGetMenuPropsCalledCorrectly(this._menuNode, this.getMenuProps);\n        }\n      }\n\n      if (isControlledProp(this.props, 'selectedItem') && this.props.selectedItemChanged(prevProps.selectedItem, this.props.selectedItem)) {\n        this.internalSetState({\n          type: controlledPropUpdatedSelectedItem,\n          inputValue: this.props.itemToString(this.props.selectedItem)\n        });\n      }\n\n      if (!this.avoidScrolling && this.shouldScroll(prevState, prevProps)) {\n        this.scrollHighlightedItemIntoView();\n      }\n      /* istanbul ignore else (react-native) */\n\n\n      {\n        this.updateStatus();\n      }\n    }\n\n    componentWillUnmount() {\n      this.cleanup(); // avoids memory leak\n    }\n\n    render() {\n      const children = unwrapArray(this.props.children, noop); // because the items are rerendered every time we call the children\n      // we clear this out each render and it will be populated again as\n      // getItemProps is called.\n\n      this.clearItems(); // we reset this so we know whether the user calls getRootProps during\n      // this render. If they do then we don't need to do anything,\n      // if they don't then we need to clone the element they return and\n      // apply the props for them.\n\n      this.getRootProps.called = false;\n      this.getRootProps.refKey = undefined;\n      this.getRootProps.suppressRefError = undefined; // we do something similar for getMenuProps\n\n      this.getMenuProps.called = false;\n      this.getMenuProps.refKey = undefined;\n      this.getMenuProps.suppressRefError = undefined; // we do something similar for getLabelProps\n\n      this.getLabelProps.called = false; // and something similar for getInputProps\n\n      this.getInputProps.called = false;\n      const element = unwrapArray(children(this.getStateAndHelpers()));\n\n      if (!element) {\n        return null;\n      }\n\n      if (this.getRootProps.called || this.props.suppressRefError) {\n        if (process.env.NODE_ENV !== 'production' && !this.getRootProps.suppressRefError && !this.props.suppressRefError) {\n          validateGetRootPropsCalledCorrectly(element, this.getRootProps);\n        }\n\n        return element;\n      } else if (isDOMElement(element)) {\n        // they didn't apply the root props, but we can clone\n        // this and apply the props ourselves\n        return /*#__PURE__*/cloneElement(element, this.getRootProps(getElementProps(element)));\n      }\n      /* istanbul ignore else */\n\n\n      if (process.env.NODE_ENV !== 'production') {\n        // they didn't apply the root props, but they need to\n        // otherwise we can't query around the autocomplete\n        throw new Error('downshift: If you return a non-DOM element, you must apply the getRootProps function');\n      }\n      /* istanbul ignore next */\n\n\n      return undefined;\n    }\n\n  }\n\n  Downshift.defaultProps = {\n    defaultHighlightedIndex: null,\n    defaultIsOpen: false,\n    getA11yStatusMessage: getA11yStatusMessage$1,\n    itemToString: i => {\n      if (i == null) {\n        return '';\n      }\n\n      if (process.env.NODE_ENV !== 'production' && isPlainObject(i) && !i.hasOwnProperty('toString')) {\n        // eslint-disable-next-line no-console\n        console.warn('downshift: An object was passed to the default implementation of `itemToString`. You should probably provide your own `itemToString` implementation. Please refer to the `itemToString` API documentation.', 'The object that was passed:', i);\n      }\n\n      return String(i);\n    },\n    onStateChange: noop,\n    onInputValueChange: noop,\n    onUserAction: noop,\n    onChange: noop,\n    onSelect: noop,\n    onOuterClick: noop,\n    selectedItemChanged: (prevItem, item) => prevItem !== item,\n    environment:\n    /* istanbul ignore next (ssr) */\n    typeof window === 'undefined' ? {} : window,\n    stateReducer: (state, stateToSet) => stateToSet,\n    suppressRefError: false,\n    scrollIntoView\n  };\n  Downshift.stateChangeTypes = stateChangeTypes$3;\n  return Downshift;\n})();\n\nprocess.env.NODE_ENV !== \"production\" ? Downshift.propTypes = {\n  children: PropTypes.func,\n  defaultHighlightedIndex: PropTypes.number,\n  defaultIsOpen: PropTypes.bool,\n  initialHighlightedIndex: PropTypes.number,\n  initialSelectedItem: PropTypes.any,\n  initialInputValue: PropTypes.string,\n  initialIsOpen: PropTypes.bool,\n  getA11yStatusMessage: PropTypes.func,\n  itemToString: PropTypes.func,\n  onChange: PropTypes.func,\n  onSelect: PropTypes.func,\n  onStateChange: PropTypes.func,\n  onInputValueChange: PropTypes.func,\n  onUserAction: PropTypes.func,\n  onOuterClick: PropTypes.func,\n  selectedItemChanged: PropTypes.func,\n  stateReducer: PropTypes.func,\n  itemCount: PropTypes.number,\n  id: PropTypes.string,\n  environment: PropTypes.shape({\n    addEventListener: PropTypes.func,\n    removeEventListener: PropTypes.func,\n    document: PropTypes.shape({\n      getElementById: PropTypes.func,\n      activeElement: PropTypes.any,\n      body: PropTypes.any\n    })\n  }),\n  suppressRefError: PropTypes.bool,\n  scrollIntoView: PropTypes.func,\n  // things we keep in state for uncontrolled components\n  // but can accept as props for controlled components\n\n  /* eslint-disable react/no-unused-prop-types */\n  selectedItem: PropTypes.any,\n  isOpen: PropTypes.bool,\n  inputValue: PropTypes.string,\n  highlightedIndex: PropTypes.number,\n  labelId: PropTypes.string,\n  inputId: PropTypes.string,\n  menuId: PropTypes.string,\n  getItemId: PropTypes.func\n  /* eslint-enable react/no-unused-prop-types */\n\n} : void 0;\nvar Downshift$1 = Downshift;\n\nfunction validateGetMenuPropsCalledCorrectly(node, _ref3) {\n  let {\n    refKey\n  } = _ref3;\n\n  if (!node) {\n    // eslint-disable-next-line no-console\n    console.error(`downshift: The ref prop \"${refKey}\" from getMenuProps was not applied correctly on your menu element.`);\n  }\n}\n\nfunction validateGetRootPropsCalledCorrectly(element, _ref4) {\n  let {\n    refKey\n  } = _ref4;\n  const refKeySpecified = refKey !== 'ref';\n  const isComposite = !isDOMElement(element);\n\n  if (isComposite && !refKeySpecified && !isForwardRef(element)) {\n    // eslint-disable-next-line no-console\n    console.error('downshift: You returned a non-DOM element. You must specify a refKey in getRootProps');\n  } else if (!isComposite && refKeySpecified) {\n    // eslint-disable-next-line no-console\n    console.error(`downshift: You returned a DOM element. You should not specify a refKey in getRootProps. You specified \"${refKey}\"`);\n  }\n\n  if (!isForwardRef(element) && !getElementProps(element)[refKey]) {\n    // eslint-disable-next-line no-console\n    console.error(`downshift: You must apply the ref prop \"${refKey}\" from getRootProps onto your root element.`);\n  }\n}\n\nconst dropdownDefaultStateValues = {\n  highlightedIndex: -1,\n  isOpen: false,\n  selectedItem: null,\n  inputValue: ''\n};\n\nfunction callOnChangeProps(action, state, newState) {\n  const {\n    props,\n    type\n  } = action;\n  const changes = {};\n  Object.keys(state).forEach(key => {\n    invokeOnChangeHandler(key, action, state, newState);\n\n    if (newState[key] !== state[key]) {\n      changes[key] = newState[key];\n    }\n  });\n\n  if (props.onStateChange && Object.keys(changes).length) {\n    props.onStateChange({\n      type,\n      ...changes\n    });\n  }\n}\n\nfunction invokeOnChangeHandler(key, action, state, newState) {\n  const {\n    props,\n    type\n  } = action;\n  const handler = `on${capitalizeString(key)}Change`;\n\n  if (props[handler] && newState[key] !== undefined && newState[key] !== state[key]) {\n    props[handler]({\n      type,\n      ...newState\n    });\n  }\n}\n/**\n * Default state reducer that returns the changes.\n *\n * @param {Object} s state.\n * @param {Object} a action with changes.\n * @returns {Object} changes.\n */\n\n\nfunction stateReducer(s, a) {\n  return a.changes;\n}\n/**\n * Returns a message to be added to aria-live region when item is selected.\n *\n * @param {Object} selectionParameters Parameters required to build the message.\n * @returns {string} The a11y message.\n */\n\n\nfunction getA11ySelectionMessage(selectionParameters) {\n  const {\n    selectedItem,\n    itemToString: itemToStringLocal\n  } = selectionParameters;\n  return selectedItem ? `${itemToStringLocal(selectedItem)} has been selected.` : '';\n}\n/**\n * Debounced call for updating the a11y message.\n */\n\n\nconst updateA11yStatus = debounce((getA11yMessage, document) => {\n  setStatus(getA11yMessage(), document);\n}, 200); // istanbul ignore next\n\nconst useIsomorphicLayoutEffect = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined' ? useLayoutEffect : useEffect;\n\nfunction useElementIds(_ref) {\n  let {\n    id = `downshift-${generateId()}`,\n    labelId,\n    menuId,\n    getItemId,\n    toggleButtonId,\n    inputId\n  } = _ref;\n  const elementIdsRef = useRef({\n    labelId: labelId || `${id}-label`,\n    menuId: menuId || `${id}-menu`,\n    getItemId: getItemId || (index => `${id}-item-${index}`),\n    toggleButtonId: toggleButtonId || `${id}-toggle-button`,\n    inputId: inputId || `${id}-input`\n  });\n  return elementIdsRef.current;\n}\n\nfunction getItemIndex(index, item, items) {\n  if (index !== undefined) {\n    return index;\n  }\n\n  if (items.length === 0) {\n    return -1;\n  }\n\n  return items.indexOf(item);\n}\n\nfunction itemToString(item) {\n  return item ? String(item) : '';\n}\n\nfunction isAcceptedCharacterKey(key) {\n  return /^\\S{1}$/.test(key);\n}\n\nfunction capitalizeString(string) {\n  return `${string.slice(0, 1).toUpperCase()}${string.slice(1)}`;\n}\n\nfunction useLatestRef(val) {\n  const ref = useRef(val); // technically this is not \"concurrent mode safe\" because we're manipulating\n  // the value during render (so it's not idempotent). However, the places this\n  // hook is used is to support memoizing callbacks which will be called\n  // *during* render, so we need the latest values *during* render.\n  // If not for this, then we'd probably want to use useLayoutEffect instead.\n\n  ref.current = val;\n  return ref;\n}\n/**\n * Computes the controlled state using a the previous state, props,\n * two reducers, one from downshift and an optional one from the user.\n * Also calls the onChange handlers for state values that have changed.\n *\n * @param {Function} reducer Reducer function from downshift.\n * @param {Object} initialState Initial state of the hook.\n * @param {Object} props The hook props.\n * @returns {Array} An array with the state and an action dispatcher.\n */\n\n\nfunction useEnhancedReducer(reducer, initialState, props) {\n  const prevStateRef = useRef();\n  const actionRef = useRef();\n  const enhancedReducer = useCallback((state, action) => {\n    actionRef.current = action;\n    state = getState(state, action.props);\n    const changes = reducer(state, action);\n    const newState = action.props.stateReducer(state, { ...action,\n      changes\n    });\n    return newState;\n  }, [reducer]);\n  const [state, dispatch] = useReducer(enhancedReducer, initialState);\n  const propsRef = useLatestRef(props);\n  const dispatchWithProps = useCallback(action => dispatch({\n    props: propsRef.current,\n    ...action\n  }), [propsRef]);\n  const action = actionRef.current;\n  useEffect(() => {\n    if (action && prevStateRef.current && prevStateRef.current !== state) {\n      callOnChangeProps(action, getState(prevStateRef.current, action.props), state);\n    }\n\n    prevStateRef.current = state;\n  }, [state, props, action]);\n  return [state, dispatchWithProps];\n}\n/**\n * Wraps the useEnhancedReducer and applies the controlled prop values before\n * returning the new state.\n *\n * @param {Function} reducer Reducer function from downshift.\n * @param {Object} initialState Initial state of the hook.\n * @param {Object} props The hook props.\n * @returns {Array} An array with the state and an action dispatcher.\n */\n\n\nfunction useControlledReducer$1(reducer, initialState, props) {\n  const [state, dispatch] = useEnhancedReducer(reducer, initialState, props);\n  return [getState(state, props), dispatch];\n}\n\nconst defaultProps$3 = {\n  itemToString,\n  stateReducer,\n  getA11ySelectionMessage,\n  scrollIntoView,\n  circularNavigation: false,\n  environment:\n  /* istanbul ignore next (ssr) */\n  typeof window === 'undefined' ? {} : window\n};\n\nfunction getDefaultValue$1(props, propKey, defaultStateValues) {\n  if (defaultStateValues === void 0) {\n    defaultStateValues = dropdownDefaultStateValues;\n  }\n\n  const defaultValue = props[`default${capitalizeString(propKey)}`];\n\n  if (defaultValue !== undefined) {\n    return defaultValue;\n  }\n\n  return defaultStateValues[propKey];\n}\n\nfunction getInitialValue$1(props, propKey, defaultStateValues) {\n  if (defaultStateValues === void 0) {\n    defaultStateValues = dropdownDefaultStateValues;\n  }\n\n  const value = props[propKey];\n\n  if (value !== undefined) {\n    return value;\n  }\n\n  const initialValue = props[`initial${capitalizeString(propKey)}`];\n\n  if (initialValue !== undefined) {\n    return initialValue;\n  }\n\n  return getDefaultValue$1(props, propKey, defaultStateValues);\n}\n\nfunction getInitialState$2(props) {\n  const selectedItem = getInitialValue$1(props, 'selectedItem');\n  const isOpen = getInitialValue$1(props, 'isOpen');\n  const highlightedIndex = getInitialValue$1(props, 'highlightedIndex');\n  const inputValue = getInitialValue$1(props, 'inputValue');\n  return {\n    highlightedIndex: highlightedIndex < 0 && selectedItem && isOpen ? props.items.indexOf(selectedItem) : highlightedIndex,\n    isOpen,\n    selectedItem,\n    inputValue\n  };\n}\n\nfunction getHighlightedIndexOnOpen(props, state, offset, getItemNodeFromIndex) {\n  const {\n    items,\n    initialHighlightedIndex,\n    defaultHighlightedIndex\n  } = props;\n  const {\n    selectedItem,\n    highlightedIndex\n  } = state;\n\n  if (items.length === 0) {\n    return -1;\n  } // initialHighlightedIndex will give value to highlightedIndex on initial state only.\n\n\n  if (initialHighlightedIndex !== undefined && highlightedIndex === initialHighlightedIndex) {\n    return initialHighlightedIndex;\n  }\n\n  if (defaultHighlightedIndex !== undefined) {\n    return defaultHighlightedIndex;\n  }\n\n  if (selectedItem) {\n    if (offset === 0) {\n      return items.indexOf(selectedItem);\n    }\n\n    return getNextWrappingIndex(offset, items.indexOf(selectedItem), items.length, getItemNodeFromIndex, false);\n  }\n\n  if (offset === 0) {\n    return -1;\n  }\n\n  return offset < 0 ? items.length - 1 : 0;\n}\n/**\n * Reuse the movement tracking of mouse and touch events.\n *\n * @param {boolean} isOpen Whether the dropdown is open or not.\n * @param {Array<Object>} downshiftElementRefs Downshift element refs to track movement (toggleButton, menu etc.)\n * @param {Object} environment Environment where component/hook exists.\n * @param {Function} handleBlur Handler on blur from mouse or touch.\n * @returns {Object} Ref containing whether mouseDown or touchMove event is happening\n */\n\n\nfunction useMouseAndTouchTracker(isOpen, downshiftElementRefs, environment, handleBlur) {\n  const mouseAndTouchTrackersRef = useRef({\n    isMouseDown: false,\n    isTouchMove: false\n  });\n  useEffect(() => {\n    // The same strategy for checking if a click occurred inside or outside downsift\n    // as in downshift.js.\n    const onMouseDown = () => {\n      mouseAndTouchTrackersRef.current.isMouseDown = true;\n    };\n\n    const onMouseUp = event => {\n      mouseAndTouchTrackersRef.current.isMouseDown = false;\n\n      if (isOpen && !targetWithinDownshift(event.target, downshiftElementRefs.map(ref => ref.current), environment)) {\n        handleBlur();\n      }\n    };\n\n    const onTouchStart = () => {\n      mouseAndTouchTrackersRef.current.isTouchMove = false;\n    };\n\n    const onTouchMove = () => {\n      mouseAndTouchTrackersRef.current.isTouchMove = true;\n    };\n\n    const onTouchEnd = event => {\n      if (isOpen && !mouseAndTouchTrackersRef.current.isTouchMove && !targetWithinDownshift(event.target, downshiftElementRefs.map(ref => ref.current), environment, false)) {\n        handleBlur();\n      }\n    };\n\n    environment.addEventListener('mousedown', onMouseDown);\n    environment.addEventListener('mouseup', onMouseUp);\n    environment.addEventListener('touchstart', onTouchStart);\n    environment.addEventListener('touchmove', onTouchMove);\n    environment.addEventListener('touchend', onTouchEnd);\n    return function cleanup() {\n      environment.removeEventListener('mousedown', onMouseDown);\n      environment.removeEventListener('mouseup', onMouseUp);\n      environment.removeEventListener('touchstart', onTouchStart);\n      environment.removeEventListener('touchmove', onTouchMove);\n      environment.removeEventListener('touchend', onTouchEnd);\n    }; // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [isOpen, environment]);\n  return mouseAndTouchTrackersRef;\n}\n/* istanbul ignore next */\n// eslint-disable-next-line import/no-mutable-exports\n\n\nlet useGetterPropsCalledChecker = () => noop;\n/**\n * Custom hook that checks if getter props are called correctly.\n *\n * @param  {...any} propKeys Getter prop names to be handled.\n * @returns {Function} Setter function called inside getter props to set call information.\n */\n\n/* istanbul ignore next */\n\n\nif (process.env.NODE_ENV !== 'production') {\n  useGetterPropsCalledChecker = function () {\n    const isInitialMountRef = useRef(true);\n\n    for (var _len = arguments.length, propKeys = new Array(_len), _key = 0; _key < _len; _key++) {\n      propKeys[_key] = arguments[_key];\n    }\n\n    const getterPropsCalledRef = useRef(propKeys.reduce((acc, propKey) => {\n      acc[propKey] = {};\n      return acc;\n    }, {}));\n    useEffect(() => {\n      Object.keys(getterPropsCalledRef.current).forEach(propKey => {\n        const propCallInfo = getterPropsCalledRef.current[propKey];\n\n        if (isInitialMountRef.current) {\n          if (!Object.keys(propCallInfo).length) {\n            // eslint-disable-next-line no-console\n            console.error(`downshift: You forgot to call the ${propKey} getter function on your component / element.`);\n            return;\n          }\n        }\n\n        const {\n          suppressRefError,\n          refKey,\n          elementRef\n        } = propCallInfo;\n\n        if ((!elementRef || !elementRef.current) && !suppressRefError) {\n          // eslint-disable-next-line no-console\n          console.error(`downshift: The ref prop \"${refKey}\" from ${propKey} was not applied correctly on your element.`);\n        }\n      });\n      isInitialMountRef.current = false;\n    });\n    const setGetterPropCallInfo = useCallback((propKey, suppressRefError, refKey, elementRef) => {\n      getterPropsCalledRef.current[propKey] = {\n        suppressRefError,\n        refKey,\n        elementRef\n      };\n    }, []);\n    return setGetterPropCallInfo;\n  };\n}\n\nfunction useA11yMessageSetter(getA11yMessage, dependencyArray, _ref2) {\n  let {\n    isInitialMount,\n    highlightedIndex,\n    items,\n    environment,\n    ...rest\n  } = _ref2;\n  // Sets a11y status message on changes in state.\n  useEffect(() => {\n    if (isInitialMount || false) {\n      return;\n    }\n\n    updateA11yStatus(() => getA11yMessage({\n      highlightedIndex,\n      highlightedItem: items[highlightedIndex],\n      resultCount: items.length,\n      ...rest\n    }), environment.document); // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, dependencyArray);\n}\n\nfunction useScrollIntoView(_ref3) {\n  let {\n    highlightedIndex,\n    isOpen,\n    itemRefs,\n    getItemNodeFromIndex,\n    menuElement,\n    scrollIntoView: scrollIntoViewProp\n  } = _ref3;\n  // used not to scroll on highlight by mouse.\n  const shouldScrollRef = useRef(true); // Scroll on highlighted item if change comes from keyboard.\n\n  useIsomorphicLayoutEffect(() => {\n    if (highlightedIndex < 0 || !isOpen || !Object.keys(itemRefs.current).length) {\n      return;\n    }\n\n    if (shouldScrollRef.current === false) {\n      shouldScrollRef.current = true;\n    } else {\n      scrollIntoViewProp(getItemNodeFromIndex(highlightedIndex), menuElement);\n    } // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, [highlightedIndex]);\n  return shouldScrollRef;\n} // eslint-disable-next-line import/no-mutable-exports\n\n\nlet useControlPropsValidator = noop;\n/* istanbul ignore next */\n\nif (process.env.NODE_ENV !== 'production') {\n  useControlPropsValidator = _ref4 => {\n    let {\n      isInitialMount,\n      props,\n      state\n    } = _ref4;\n    // used for checking when props are moving from controlled to uncontrolled.\n    const prevPropsRef = useRef(props);\n    useEffect(() => {\n      if (isInitialMount) {\n        return;\n      }\n\n      validateControlledUnchanged(state, prevPropsRef.current, props);\n      prevPropsRef.current = props;\n    }, [state, props, isInitialMount]);\n  };\n}\n\n/* eslint-disable complexity */\n\nfunction downshiftCommonReducer(state, action, stateChangeTypes) {\n  const {\n    type,\n    props\n  } = action;\n  let changes;\n\n  switch (type) {\n    case stateChangeTypes.ItemMouseMove:\n      changes = {\n        highlightedIndex: action.disabled ? -1 : action.index\n      };\n      break;\n\n    case stateChangeTypes.MenuMouseLeave:\n      changes = {\n        highlightedIndex: -1\n      };\n      break;\n\n    case stateChangeTypes.ToggleButtonClick:\n    case stateChangeTypes.FunctionToggleMenu:\n      changes = {\n        isOpen: !state.isOpen,\n        highlightedIndex: state.isOpen ? -1 : getHighlightedIndexOnOpen(props, state, 0)\n      };\n      break;\n\n    case stateChangeTypes.FunctionOpenMenu:\n      changes = {\n        isOpen: true,\n        highlightedIndex: getHighlightedIndexOnOpen(props, state, 0)\n      };\n      break;\n\n    case stateChangeTypes.FunctionCloseMenu:\n      changes = {\n        isOpen: false\n      };\n      break;\n\n    case stateChangeTypes.FunctionSetHighlightedIndex:\n      changes = {\n        highlightedIndex: action.highlightedIndex\n      };\n      break;\n\n    case stateChangeTypes.FunctionSetInputValue:\n      changes = {\n        inputValue: action.inputValue\n      };\n      break;\n\n    case stateChangeTypes.FunctionReset:\n      changes = {\n        highlightedIndex: getDefaultValue$1(props, 'highlightedIndex'),\n        isOpen: getDefaultValue$1(props, 'isOpen'),\n        selectedItem: getDefaultValue$1(props, 'selectedItem'),\n        inputValue: getDefaultValue$1(props, 'inputValue')\n      };\n      break;\n\n    default:\n      throw new Error('Reducer called without proper action type.');\n  }\n\n  return { ...state,\n    ...changes\n  };\n}\n/* eslint-enable complexity */\n\nfunction getItemIndexByCharacterKey(_a) {\n    var keysSoFar = _a.keysSoFar, highlightedIndex = _a.highlightedIndex, items = _a.items, itemToString = _a.itemToString, getItemNodeFromIndex = _a.getItemNodeFromIndex;\n    var lowerCasedKeysSoFar = keysSoFar.toLowerCase();\n    for (var index = 0; index < items.length; index++) {\n        var offsetIndex = (index + highlightedIndex + 1) % items.length;\n        var item = items[offsetIndex];\n        if (item !== undefined &&\n            itemToString(item)\n                .toLowerCase()\n                .startsWith(lowerCasedKeysSoFar)) {\n            var element = getItemNodeFromIndex(offsetIndex);\n            if (!(element === null || element === void 0 ? void 0 : element.hasAttribute('disabled'))) {\n                return offsetIndex;\n            }\n        }\n    }\n    return highlightedIndex;\n}\nvar propTypes$2 = {\n    items: PropTypes.array.isRequired,\n    itemToString: PropTypes.func,\n    getA11yStatusMessage: PropTypes.func,\n    getA11ySelectionMessage: PropTypes.func,\n    circularNavigation: PropTypes.bool,\n    highlightedIndex: PropTypes.number,\n    defaultHighlightedIndex: PropTypes.number,\n    initialHighlightedIndex: PropTypes.number,\n    isOpen: PropTypes.bool,\n    defaultIsOpen: PropTypes.bool,\n    initialIsOpen: PropTypes.bool,\n    selectedItem: PropTypes.any,\n    initialSelectedItem: PropTypes.any,\n    defaultSelectedItem: PropTypes.any,\n    id: PropTypes.string,\n    labelId: PropTypes.string,\n    menuId: PropTypes.string,\n    getItemId: PropTypes.func,\n    toggleButtonId: PropTypes.string,\n    stateReducer: PropTypes.func,\n    onSelectedItemChange: PropTypes.func,\n    onHighlightedIndexChange: PropTypes.func,\n    onStateChange: PropTypes.func,\n    onIsOpenChange: PropTypes.func,\n    environment: PropTypes.shape({\n        addEventListener: PropTypes.func,\n        removeEventListener: PropTypes.func,\n        document: PropTypes.shape({\n            getElementById: PropTypes.func,\n            activeElement: PropTypes.any,\n            body: PropTypes.any\n        })\n    })\n};\n/**\n * Default implementation for status message. Only added when menu is open.\n * Will specift if there are results in the list, and if so, how many,\n * and what keys are relevant.\n *\n * @param {Object} param the downshift state and other relevant properties\n * @return {String} the a11y status message\n */\nfunction getA11yStatusMessage(_a) {\n    var isOpen = _a.isOpen, resultCount = _a.resultCount, previousResultCount = _a.previousResultCount;\n    if (!isOpen) {\n        return '';\n    }\n    if (!resultCount) {\n        return 'No results are available.';\n    }\n    if (resultCount !== previousResultCount) {\n        return \"\".concat(resultCount, \" result\").concat(resultCount === 1 ? ' is' : 's are', \" available, use up and down arrow keys to navigate. Press Enter or Space Bar keys to select.\");\n    }\n    return '';\n}\nvar defaultProps$2 = __assign(__assign({}, defaultProps$3), { getA11yStatusMessage: getA11yStatusMessage });\n// eslint-disable-next-line import/no-mutable-exports\nvar validatePropTypes$2 = noop;\n/* istanbul ignore next */\nif (process.env.NODE_ENV !== 'production') {\n    validatePropTypes$2 = function (options, caller) {\n        PropTypes.checkPropTypes(propTypes$2, options, 'prop', caller.name);\n    };\n}\n\nconst MenuKeyDownArrowDown = process.env.NODE_ENV !== \"production\" ? '__menu_keydown_arrow_down__' : 0;\nconst MenuKeyDownArrowUp = process.env.NODE_ENV !== \"production\" ? '__menu_keydown_arrow_up__' : 1;\nconst MenuKeyDownEscape = process.env.NODE_ENV !== \"production\" ? '__menu_keydown_escape__' : 2;\nconst MenuKeyDownHome = process.env.NODE_ENV !== \"production\" ? '__menu_keydown_home__' : 3;\nconst MenuKeyDownEnd = process.env.NODE_ENV !== \"production\" ? '__menu_keydown_end__' : 4;\nconst MenuKeyDownEnter = process.env.NODE_ENV !== \"production\" ? '__menu_keydown_enter__' : 5;\nconst MenuKeyDownSpaceButton = process.env.NODE_ENV !== \"production\" ? '__menu_keydown_space_button__' : 6;\nconst MenuKeyDownCharacter = process.env.NODE_ENV !== \"production\" ? '__menu_keydown_character__' : 7;\nconst MenuBlur = process.env.NODE_ENV !== \"production\" ? '__menu_blur__' : 8;\nconst MenuMouseLeave$1 = process.env.NODE_ENV !== \"production\" ? '__menu_mouse_leave__' : 9;\nconst ItemMouseMove$1 = process.env.NODE_ENV !== \"production\" ? '__item_mouse_move__' : 10;\nconst ItemClick$1 = process.env.NODE_ENV !== \"production\" ? '__item_click__' : 11;\nconst ToggleButtonClick$1 = process.env.NODE_ENV !== \"production\" ? '__togglebutton_click__' : 12;\nconst ToggleButtonKeyDownArrowDown = process.env.NODE_ENV !== \"production\" ? '__togglebutton_keydown_arrow_down__' : 13;\nconst ToggleButtonKeyDownArrowUp = process.env.NODE_ENV !== \"production\" ? '__togglebutton_keydown_arrow_up__' : 14;\nconst ToggleButtonKeyDownCharacter = process.env.NODE_ENV !== \"production\" ? '__togglebutton_keydown_character__' : 15;\nconst FunctionToggleMenu$1 = process.env.NODE_ENV !== \"production\" ? '__function_toggle_menu__' : 16;\nconst FunctionOpenMenu$1 = process.env.NODE_ENV !== \"production\" ? '__function_open_menu__' : 17;\nconst FunctionCloseMenu$1 = process.env.NODE_ENV !== \"production\" ? '__function_close_menu__' : 18;\nconst FunctionSetHighlightedIndex$1 = process.env.NODE_ENV !== \"production\" ? '__function_set_highlighted_index__' : 19;\nconst FunctionSelectItem$1 = process.env.NODE_ENV !== \"production\" ? '__function_select_item__' : 20;\nconst FunctionSetInputValue$1 = process.env.NODE_ENV !== \"production\" ? '__function_set_input_value__' : 21;\nconst FunctionReset$2 = process.env.NODE_ENV !== \"production\" ? '__function_reset__' : 22;\n\nvar stateChangeTypes$2 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  MenuKeyDownArrowDown: MenuKeyDownArrowDown,\n  MenuKeyDownArrowUp: MenuKeyDownArrowUp,\n  MenuKeyDownEscape: MenuKeyDownEscape,\n  MenuKeyDownHome: MenuKeyDownHome,\n  MenuKeyDownEnd: MenuKeyDownEnd,\n  MenuKeyDownEnter: MenuKeyDownEnter,\n  MenuKeyDownSpaceButton: MenuKeyDownSpaceButton,\n  MenuKeyDownCharacter: MenuKeyDownCharacter,\n  MenuBlur: MenuBlur,\n  MenuMouseLeave: MenuMouseLeave$1,\n  ItemMouseMove: ItemMouseMove$1,\n  ItemClick: ItemClick$1,\n  ToggleButtonClick: ToggleButtonClick$1,\n  ToggleButtonKeyDownArrowDown: ToggleButtonKeyDownArrowDown,\n  ToggleButtonKeyDownArrowUp: ToggleButtonKeyDownArrowUp,\n  ToggleButtonKeyDownCharacter: ToggleButtonKeyDownCharacter,\n  FunctionToggleMenu: FunctionToggleMenu$1,\n  FunctionOpenMenu: FunctionOpenMenu$1,\n  FunctionCloseMenu: FunctionCloseMenu$1,\n  FunctionSetHighlightedIndex: FunctionSetHighlightedIndex$1,\n  FunctionSelectItem: FunctionSelectItem$1,\n  FunctionSetInputValue: FunctionSetInputValue$1,\n  FunctionReset: FunctionReset$2\n});\n\n/* eslint-disable complexity */\n\nfunction downshiftSelectReducer(state, action) {\n  const {\n    type,\n    props,\n    shiftKey\n  } = action;\n  let changes;\n\n  switch (type) {\n    case ItemClick$1:\n      changes = {\n        isOpen: getDefaultValue$1(props, 'isOpen'),\n        highlightedIndex: getDefaultValue$1(props, 'highlightedIndex'),\n        selectedItem: props.items[action.index]\n      };\n      break;\n\n    case ToggleButtonKeyDownCharacter:\n      {\n        const lowercasedKey = action.key;\n        const inputValue = `${state.inputValue}${lowercasedKey}`;\n        const itemIndex = getItemIndexByCharacterKey({\n          keysSoFar: inputValue,\n          highlightedIndex: state.selectedItem ? props.items.indexOf(state.selectedItem) : -1,\n          items: props.items,\n          itemToString: props.itemToString,\n          getItemNodeFromIndex: action.getItemNodeFromIndex\n        });\n        changes = {\n          inputValue,\n          ...(itemIndex >= 0 && {\n            selectedItem: props.items[itemIndex]\n          })\n        };\n      }\n      break;\n\n    case ToggleButtonKeyDownArrowDown:\n      changes = {\n        highlightedIndex: getHighlightedIndexOnOpen(props, state, 1, action.getItemNodeFromIndex),\n        isOpen: true\n      };\n      break;\n\n    case ToggleButtonKeyDownArrowUp:\n      changes = {\n        highlightedIndex: getHighlightedIndexOnOpen(props, state, -1, action.getItemNodeFromIndex),\n        isOpen: true\n      };\n      break;\n\n    case MenuKeyDownEnter:\n    case MenuKeyDownSpaceButton:\n      changes = {\n        isOpen: getDefaultValue$1(props, 'isOpen'),\n        highlightedIndex: getDefaultValue$1(props, 'highlightedIndex'),\n        ...(state.highlightedIndex >= 0 && {\n          selectedItem: props.items[state.highlightedIndex]\n        })\n      };\n      break;\n\n    case MenuKeyDownHome:\n      changes = {\n        highlightedIndex: getNextNonDisabledIndex(1, 0, props.items.length, action.getItemNodeFromIndex, false)\n      };\n      break;\n\n    case MenuKeyDownEnd:\n      changes = {\n        highlightedIndex: getNextNonDisabledIndex(-1, props.items.length - 1, props.items.length, action.getItemNodeFromIndex, false)\n      };\n      break;\n\n    case MenuKeyDownEscape:\n      changes = {\n        isOpen: false,\n        highlightedIndex: -1\n      };\n      break;\n\n    case MenuBlur:\n      changes = {\n        isOpen: false,\n        highlightedIndex: -1\n      };\n      break;\n\n    case MenuKeyDownCharacter:\n      {\n        const lowercasedKey = action.key;\n        const inputValue = `${state.inputValue}${lowercasedKey}`;\n        const highlightedIndex = getItemIndexByCharacterKey({\n          keysSoFar: inputValue,\n          highlightedIndex: state.highlightedIndex,\n          items: props.items,\n          itemToString: props.itemToString,\n          getItemNodeFromIndex: action.getItemNodeFromIndex\n        });\n        changes = {\n          inputValue,\n          ...(highlightedIndex >= 0 && {\n            highlightedIndex\n          })\n        };\n      }\n      break;\n\n    case MenuKeyDownArrowDown:\n      changes = {\n        highlightedIndex: getNextWrappingIndex(shiftKey ? 5 : 1, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, props.circularNavigation)\n      };\n      break;\n\n    case MenuKeyDownArrowUp:\n      changes = {\n        highlightedIndex: getNextWrappingIndex(shiftKey ? -5 : -1, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, props.circularNavigation)\n      };\n      break;\n\n    case FunctionSelectItem$1:\n      changes = {\n        selectedItem: action.selectedItem\n      };\n      break;\n\n    default:\n      return downshiftCommonReducer(state, action, stateChangeTypes$2);\n  }\n\n  return { ...state,\n    ...changes\n  };\n}\n/* eslint-enable complexity */\n\n/* eslint-disable max-statements */\nuseSelect.stateChangeTypes = stateChangeTypes$2;\n\nfunction useSelect(userProps) {\n  if (userProps === void 0) {\n    userProps = {};\n  }\n\n  validatePropTypes$2(userProps, useSelect); // Props defaults and destructuring.\n\n  const props = { ...defaultProps$2,\n    ...userProps\n  };\n  const {\n    items,\n    scrollIntoView,\n    environment,\n    initialIsOpen,\n    defaultIsOpen,\n    itemToString,\n    getA11ySelectionMessage,\n    getA11yStatusMessage\n  } = props; // Initial state depending on controlled props.\n\n  const initialState = getInitialState$2(props);\n  const [state, dispatch] = useControlledReducer$1(downshiftSelectReducer, initialState, props);\n  const {\n    isOpen,\n    highlightedIndex,\n    selectedItem,\n    inputValue\n  } = state; // Element efs.\n\n  const toggleButtonRef = useRef(null);\n  const menuRef = useRef(null);\n  const itemRefs = useRef({}); // used not to trigger menu blur action in some scenarios.\n\n  const shouldBlurRef = useRef(true); // used to keep the inputValue clearTimeout object between renders.\n\n  const clearTimeoutRef = useRef(null); // prevent id re-generation between renders.\n\n  const elementIds = useElementIds(props); // used to keep track of how many items we had on previous cycle.\n\n  const previousResultCountRef = useRef();\n  const isInitialMountRef = useRef(true); // utility callback to get item element.\n\n  const latest = useLatestRef({\n    state,\n    props\n  }); // Some utils.\n\n  const getItemNodeFromIndex = useCallback(index => itemRefs.current[elementIds.getItemId(index)], [elementIds]); // Effects.\n  // Sets a11y status message on changes in state.\n\n  useA11yMessageSetter(getA11yStatusMessage, [isOpen, highlightedIndex, inputValue, items], {\n    isInitialMount: isInitialMountRef.current,\n    previousResultCount: previousResultCountRef.current,\n    items,\n    environment,\n    itemToString,\n    ...state\n  }); // Sets a11y status message on changes in selectedItem.\n\n  useA11yMessageSetter(getA11ySelectionMessage, [selectedItem], {\n    isInitialMount: isInitialMountRef.current,\n    previousResultCount: previousResultCountRef.current,\n    items,\n    environment,\n    itemToString,\n    ...state\n  }); // Scroll on highlighted item if change comes from keyboard.\n\n  const shouldScrollRef = useScrollIntoView({\n    menuElement: menuRef.current,\n    highlightedIndex,\n    isOpen,\n    itemRefs,\n    scrollIntoView,\n    getItemNodeFromIndex\n  }); // Sets cleanup for the keysSoFar callback, debounded after 500ms.\n\n  useEffect(() => {\n    // init the clean function here as we need access to dispatch.\n    clearTimeoutRef.current = debounce(outerDispatch => {\n      outerDispatch({\n        type: FunctionSetInputValue$1,\n        inputValue: ''\n      });\n    }, 500); // Cancel any pending debounced calls on mount\n\n    return () => {\n      clearTimeoutRef.current.cancel();\n    };\n  }, []); // Invokes the keysSoFar callback set up above.\n\n  useEffect(() => {\n    if (!inputValue) {\n      return;\n    }\n\n    clearTimeoutRef.current(dispatch);\n  }, [dispatch, inputValue]);\n  useControlPropsValidator({\n    isInitialMount: isInitialMountRef.current,\n    props,\n    state\n  });\n  /* Controls the focus on the menu or the toggle button. */\n\n  useEffect(() => {\n    // Don't focus menu on first render.\n    if (isInitialMountRef.current) {\n      // Unless it was initialised as open.\n      if ((initialIsOpen || defaultIsOpen || isOpen) && menuRef.current) {\n        menuRef.current.focus();\n      }\n\n      return;\n    } // Focus menu on open.\n\n\n    if (isOpen) {\n      // istanbul ignore else\n      if (menuRef.current) {\n        menuRef.current.focus();\n      }\n\n      return;\n    } // Focus toggleButton on close, but not if it was closed with (Shift+)Tab.\n\n\n    if (environment.document.activeElement === menuRef.current) {\n      // istanbul ignore else\n      if (toggleButtonRef.current) {\n        shouldBlurRef.current = false;\n        toggleButtonRef.current.focus();\n      }\n    } // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, [isOpen]);\n  useEffect(() => {\n    if (isInitialMountRef.current) {\n      return;\n    }\n\n    previousResultCountRef.current = items.length;\n  }); // Add mouse/touch events to document.\n\n  const mouseAndTouchTrackersRef = useMouseAndTouchTracker(isOpen, [menuRef, toggleButtonRef], environment, () => {\n    dispatch({\n      type: MenuBlur\n    });\n  });\n  const setGetterPropCallInfo = useGetterPropsCalledChecker('getMenuProps', 'getToggleButtonProps'); // Make initial ref false.\n\n  useEffect(() => {\n    isInitialMountRef.current = false;\n  }, []); // Reset itemRefs on close.\n\n  useEffect(() => {\n    if (!isOpen) {\n      itemRefs.current = {};\n    }\n  }, [isOpen]); // Event handler functions.\n\n  const toggleButtonKeyDownHandlers = useMemo(() => ({\n    ArrowDown(event) {\n      event.preventDefault();\n      dispatch({\n        type: ToggleButtonKeyDownArrowDown,\n        getItemNodeFromIndex,\n        shiftKey: event.shiftKey\n      });\n    },\n\n    ArrowUp(event) {\n      event.preventDefault();\n      dispatch({\n        type: ToggleButtonKeyDownArrowUp,\n        getItemNodeFromIndex,\n        shiftKey: event.shiftKey\n      });\n    }\n\n  }), [dispatch, getItemNodeFromIndex]);\n  const menuKeyDownHandlers = useMemo(() => ({\n    ArrowDown(event) {\n      event.preventDefault();\n      dispatch({\n        type: MenuKeyDownArrowDown,\n        getItemNodeFromIndex,\n        shiftKey: event.shiftKey\n      });\n    },\n\n    ArrowUp(event) {\n      event.preventDefault();\n      dispatch({\n        type: MenuKeyDownArrowUp,\n        getItemNodeFromIndex,\n        shiftKey: event.shiftKey\n      });\n    },\n\n    Home(event) {\n      event.preventDefault();\n      dispatch({\n        type: MenuKeyDownHome,\n        getItemNodeFromIndex\n      });\n    },\n\n    End(event) {\n      event.preventDefault();\n      dispatch({\n        type: MenuKeyDownEnd,\n        getItemNodeFromIndex\n      });\n    },\n\n    Escape() {\n      dispatch({\n        type: MenuKeyDownEscape\n      });\n    },\n\n    Enter(event) {\n      event.preventDefault();\n      dispatch({\n        type: MenuKeyDownEnter\n      });\n    },\n\n    ' '(event) {\n      event.preventDefault();\n      dispatch({\n        type: MenuKeyDownSpaceButton\n      });\n    }\n\n  }), [dispatch, getItemNodeFromIndex]); // Action functions.\n\n  const toggleMenu = useCallback(() => {\n    dispatch({\n      type: FunctionToggleMenu$1\n    });\n  }, [dispatch]);\n  const closeMenu = useCallback(() => {\n    dispatch({\n      type: FunctionCloseMenu$1\n    });\n  }, [dispatch]);\n  const openMenu = useCallback(() => {\n    dispatch({\n      type: FunctionOpenMenu$1\n    });\n  }, [dispatch]);\n  const setHighlightedIndex = useCallback(newHighlightedIndex => {\n    dispatch({\n      type: FunctionSetHighlightedIndex$1,\n      highlightedIndex: newHighlightedIndex\n    });\n  }, [dispatch]);\n  const selectItem = useCallback(newSelectedItem => {\n    dispatch({\n      type: FunctionSelectItem$1,\n      selectedItem: newSelectedItem\n    });\n  }, [dispatch]);\n  const reset = useCallback(() => {\n    dispatch({\n      type: FunctionReset$2\n    });\n  }, [dispatch]);\n  const setInputValue = useCallback(newInputValue => {\n    dispatch({\n      type: FunctionSetInputValue$1,\n      inputValue: newInputValue\n    });\n  }, [dispatch]); // Getter functions.\n\n  const getLabelProps = useCallback(labelProps => ({\n    id: elementIds.labelId,\n    htmlFor: elementIds.toggleButtonId,\n    ...labelProps\n  }), [elementIds]);\n  const getMenuProps = useCallback(function (_temp, _temp2) {\n    let {\n      onMouseLeave,\n      refKey = 'ref',\n      onKeyDown,\n      onBlur,\n      ref,\n      ...rest\n    } = _temp === void 0 ? {} : _temp;\n    let {\n      suppressRefError = false\n    } = _temp2 === void 0 ? {} : _temp2;\n    const latestState = latest.current.state;\n\n    const menuHandleKeyDown = event => {\n      const key = normalizeArrowKey(event);\n\n      if (key && menuKeyDownHandlers[key]) {\n        menuKeyDownHandlers[key](event);\n      } else if (isAcceptedCharacterKey(key)) {\n        dispatch({\n          type: MenuKeyDownCharacter,\n          key,\n          getItemNodeFromIndex\n        });\n      }\n    };\n\n    const menuHandleBlur = () => {\n      // if the blur was a result of selection, we don't trigger this action.\n      if (shouldBlurRef.current === false) {\n        shouldBlurRef.current = true;\n        return;\n      }\n\n      const shouldBlur = !mouseAndTouchTrackersRef.current.isMouseDown;\n      /* istanbul ignore else */\n\n      if (shouldBlur) {\n        dispatch({\n          type: MenuBlur\n        });\n      }\n    };\n\n    const menuHandleMouseLeave = () => {\n      dispatch({\n        type: MenuMouseLeave$1\n      });\n    };\n\n    setGetterPropCallInfo('getMenuProps', suppressRefError, refKey, menuRef);\n    return {\n      [refKey]: handleRefs(ref, menuNode => {\n        menuRef.current = menuNode;\n      }),\n      id: elementIds.menuId,\n      role: 'listbox',\n      'aria-labelledby': elementIds.labelId,\n      tabIndex: -1,\n      ...(latestState.isOpen && latestState.highlightedIndex > -1 && {\n        'aria-activedescendant': elementIds.getItemId(latestState.highlightedIndex)\n      }),\n      onMouseLeave: callAllEventHandlers(onMouseLeave, menuHandleMouseLeave),\n      onKeyDown: callAllEventHandlers(onKeyDown, menuHandleKeyDown),\n      onBlur: callAllEventHandlers(onBlur, menuHandleBlur),\n      ...rest\n    };\n  }, [dispatch, latest, menuKeyDownHandlers, mouseAndTouchTrackersRef, setGetterPropCallInfo, elementIds, getItemNodeFromIndex]);\n  const getToggleButtonProps = useCallback(function (_temp3, _temp4) {\n    let {\n      onClick,\n      onKeyDown,\n      refKey = 'ref',\n      ref,\n      ...rest\n    } = _temp3 === void 0 ? {} : _temp3;\n    let {\n      suppressRefError = false\n    } = _temp4 === void 0 ? {} : _temp4;\n\n    const toggleButtonHandleClick = () => {\n      dispatch({\n        type: ToggleButtonClick$1\n      });\n    };\n\n    const toggleButtonHandleKeyDown = event => {\n      const key = normalizeArrowKey(event);\n\n      if (key && toggleButtonKeyDownHandlers[key]) {\n        toggleButtonKeyDownHandlers[key](event);\n      } else if (isAcceptedCharacterKey(key)) {\n        dispatch({\n          type: ToggleButtonKeyDownCharacter,\n          key,\n          getItemNodeFromIndex\n        });\n      }\n    };\n\n    const toggleProps = {\n      [refKey]: handleRefs(ref, toggleButtonNode => {\n        toggleButtonRef.current = toggleButtonNode;\n      }),\n      id: elementIds.toggleButtonId,\n      'aria-haspopup': 'listbox',\n      'aria-expanded': latest.current.state.isOpen,\n      'aria-labelledby': `${elementIds.labelId} ${elementIds.toggleButtonId}`,\n      ...rest\n    };\n\n    if (!rest.disabled) {\n      toggleProps.onClick = callAllEventHandlers(onClick, toggleButtonHandleClick);\n      toggleProps.onKeyDown = callAllEventHandlers(onKeyDown, toggleButtonHandleKeyDown);\n    }\n\n    setGetterPropCallInfo('getToggleButtonProps', suppressRefError, refKey, toggleButtonRef);\n    return toggleProps;\n  }, [dispatch, latest, toggleButtonKeyDownHandlers, setGetterPropCallInfo, elementIds, getItemNodeFromIndex]);\n  const getItemProps = useCallback(function (_temp5) {\n    let {\n      item,\n      index,\n      onMouseMove,\n      onClick,\n      refKey = 'ref',\n      ref,\n      disabled,\n      ...rest\n    } = _temp5 === void 0 ? {} : _temp5;\n    const {\n      state: latestState,\n      props: latestProps\n    } = latest.current;\n\n    const itemHandleMouseMove = () => {\n      if (index === latestState.highlightedIndex) {\n        return;\n      }\n\n      shouldScrollRef.current = false;\n      dispatch({\n        type: ItemMouseMove$1,\n        index,\n        disabled\n      });\n    };\n\n    const itemHandleClick = () => {\n      dispatch({\n        type: ItemClick$1,\n        index\n      });\n    };\n\n    const itemIndex = getItemIndex(index, item, latestProps.items);\n\n    if (itemIndex < 0) {\n      throw new Error('Pass either item or item index in getItemProps!');\n    }\n\n    const itemProps = {\n      disabled,\n      role: 'option',\n      'aria-selected': `${itemIndex === latestState.highlightedIndex}`,\n      id: elementIds.getItemId(itemIndex),\n      [refKey]: handleRefs(ref, itemNode => {\n        if (itemNode) {\n          itemRefs.current[elementIds.getItemId(itemIndex)] = itemNode;\n        }\n      }),\n      ...rest\n    };\n\n    if (!disabled) {\n      itemProps.onClick = callAllEventHandlers(onClick, itemHandleClick);\n    }\n\n    itemProps.onMouseMove = callAllEventHandlers(onMouseMove, itemHandleMouseMove);\n    return itemProps;\n  }, [dispatch, latest, shouldScrollRef, elementIds]);\n  return {\n    // prop getters.\n    getToggleButtonProps,\n    getLabelProps,\n    getMenuProps,\n    getItemProps,\n    // actions.\n    toggleMenu,\n    openMenu,\n    closeMenu,\n    setHighlightedIndex,\n    selectItem,\n    reset,\n    setInputValue,\n    // state.\n    highlightedIndex,\n    isOpen,\n    selectedItem,\n    inputValue\n  };\n}\n\nconst InputKeyDownArrowDown = process.env.NODE_ENV !== \"production\" ? '__input_keydown_arrow_down__' : 0;\nconst InputKeyDownArrowUp = process.env.NODE_ENV !== \"production\" ? '__input_keydown_arrow_up__' : 1;\nconst InputKeyDownEscape = process.env.NODE_ENV !== \"production\" ? '__input_keydown_escape__' : 2;\nconst InputKeyDownHome = process.env.NODE_ENV !== \"production\" ? '__input_keydown_home__' : 3;\nconst InputKeyDownEnd = process.env.NODE_ENV !== \"production\" ? '__input_keydown_end__' : 4;\nconst InputKeyDownEnter = process.env.NODE_ENV !== \"production\" ? '__input_keydown_enter__' : 5;\nconst InputChange = process.env.NODE_ENV !== \"production\" ? '__input_change__' : 6;\nconst InputBlur = process.env.NODE_ENV !== \"production\" ? '__input_blur__' : 7;\nconst MenuMouseLeave = process.env.NODE_ENV !== \"production\" ? '__menu_mouse_leave__' : 8;\nconst ItemMouseMove = process.env.NODE_ENV !== \"production\" ? '__item_mouse_move__' : 9;\nconst ItemClick = process.env.NODE_ENV !== \"production\" ? '__item_click__' : 10;\nconst ToggleButtonClick = process.env.NODE_ENV !== \"production\" ? '__togglebutton_click__' : 11;\nconst FunctionToggleMenu = process.env.NODE_ENV !== \"production\" ? '__function_toggle_menu__' : 12;\nconst FunctionOpenMenu = process.env.NODE_ENV !== \"production\" ? '__function_open_menu__' : 13;\nconst FunctionCloseMenu = process.env.NODE_ENV !== \"production\" ? '__function_close_menu__' : 14;\nconst FunctionSetHighlightedIndex = process.env.NODE_ENV !== \"production\" ? '__function_set_highlighted_index__' : 15;\nconst FunctionSelectItem = process.env.NODE_ENV !== \"production\" ? '__function_select_item__' : 16;\nconst FunctionSetInputValue = process.env.NODE_ENV !== \"production\" ? '__function_set_input_value__' : 17;\nconst FunctionReset$1 = process.env.NODE_ENV !== \"production\" ? '__function_reset__' : 18;\nconst ControlledPropUpdatedSelectedItem = process.env.NODE_ENV !== \"production\" ? '__controlled_prop_updated_selected_item__' : 19;\n\nvar stateChangeTypes$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  InputKeyDownArrowDown: InputKeyDownArrowDown,\n  InputKeyDownArrowUp: InputKeyDownArrowUp,\n  InputKeyDownEscape: InputKeyDownEscape,\n  InputKeyDownHome: InputKeyDownHome,\n  InputKeyDownEnd: InputKeyDownEnd,\n  InputKeyDownEnter: InputKeyDownEnter,\n  InputChange: InputChange,\n  InputBlur: InputBlur,\n  MenuMouseLeave: MenuMouseLeave,\n  ItemMouseMove: ItemMouseMove,\n  ItemClick: ItemClick,\n  ToggleButtonClick: ToggleButtonClick,\n  FunctionToggleMenu: FunctionToggleMenu,\n  FunctionOpenMenu: FunctionOpenMenu,\n  FunctionCloseMenu: FunctionCloseMenu,\n  FunctionSetHighlightedIndex: FunctionSetHighlightedIndex,\n  FunctionSelectItem: FunctionSelectItem,\n  FunctionSetInputValue: FunctionSetInputValue,\n  FunctionReset: FunctionReset$1,\n  ControlledPropUpdatedSelectedItem: ControlledPropUpdatedSelectedItem\n});\n\nfunction getInitialState$1(props) {\n  const initialState = getInitialState$2(props);\n  const {\n    selectedItem\n  } = initialState;\n  let {\n    inputValue\n  } = initialState;\n\n  if (inputValue === '' && selectedItem && props.defaultInputValue === undefined && props.initialInputValue === undefined && props.inputValue === undefined) {\n    inputValue = props.itemToString(selectedItem);\n  }\n\n  return { ...initialState,\n    inputValue\n  };\n}\n\nconst propTypes$1 = {\n  items: PropTypes.array.isRequired,\n  itemToString: PropTypes.func,\n  getA11yStatusMessage: PropTypes.func,\n  getA11ySelectionMessage: PropTypes.func,\n  circularNavigation: PropTypes.bool,\n  highlightedIndex: PropTypes.number,\n  defaultHighlightedIndex: PropTypes.number,\n  initialHighlightedIndex: PropTypes.number,\n  isOpen: PropTypes.bool,\n  defaultIsOpen: PropTypes.bool,\n  initialIsOpen: PropTypes.bool,\n  selectedItem: PropTypes.any,\n  initialSelectedItem: PropTypes.any,\n  defaultSelectedItem: PropTypes.any,\n  inputValue: PropTypes.string,\n  defaultInputValue: PropTypes.string,\n  initialInputValue: PropTypes.string,\n  id: PropTypes.string,\n  labelId: PropTypes.string,\n  menuId: PropTypes.string,\n  getItemId: PropTypes.func,\n  inputId: PropTypes.string,\n  toggleButtonId: PropTypes.string,\n  stateReducer: PropTypes.func,\n  onSelectedItemChange: PropTypes.func,\n  onHighlightedIndexChange: PropTypes.func,\n  onStateChange: PropTypes.func,\n  onIsOpenChange: PropTypes.func,\n  onInputValueChange: PropTypes.func,\n  environment: PropTypes.shape({\n    addEventListener: PropTypes.func,\n    removeEventListener: PropTypes.func,\n    document: PropTypes.shape({\n      getElementById: PropTypes.func,\n      activeElement: PropTypes.any,\n      body: PropTypes.any\n    })\n  })\n};\n/**\n * The useCombobox version of useControlledReducer, which also\n * checks if the controlled prop selectedItem changed between\n * renders. If so, it will also update inputValue with its\n * string equivalent. It uses the common useEnhancedReducer to\n * compute the rest of the state.\n *\n * @param {Function} reducer Reducer function from downshift.\n * @param {Object} initialState Initial state of the hook.\n * @param {Object} props The hook props.\n * @returns {Array} An array with the state and an action dispatcher.\n */\n\nfunction useControlledReducer(reducer, initialState, props) {\n  const previousSelectedItemRef = useRef();\n  const [state, dispatch] = useEnhancedReducer(reducer, initialState, props); // ToDo: if needed, make same approach as selectedItemChanged from Downshift.\n\n  useEffect(() => {\n    if (isControlledProp(props, 'selectedItem')) {\n      if (previousSelectedItemRef.current !== props.selectedItem) {\n        dispatch({\n          type: ControlledPropUpdatedSelectedItem,\n          inputValue: props.itemToString(props.selectedItem)\n        });\n      }\n\n      previousSelectedItemRef.current = state.selectedItem === previousSelectedItemRef.current ? props.selectedItem : state.selectedItem;\n    }\n  });\n  return [getState(state, props), dispatch];\n} // eslint-disable-next-line import/no-mutable-exports\n\n\nlet validatePropTypes$1 = noop;\n/* istanbul ignore next */\n\nif (process.env.NODE_ENV !== 'production') {\n  validatePropTypes$1 = (options, caller) => {\n    PropTypes.checkPropTypes(propTypes$1, options, 'prop', caller.name);\n  };\n}\n\nconst defaultProps$1 = { ...defaultProps$3,\n  getA11yStatusMessage: getA11yStatusMessage$1,\n  circularNavigation: true\n};\n\n/* eslint-disable complexity */\n\nfunction downshiftUseComboboxReducer(state, action) {\n  const {\n    type,\n    props,\n    shiftKey\n  } = action;\n  let changes;\n\n  switch (type) {\n    case ItemClick:\n      changes = {\n        isOpen: getDefaultValue$1(props, 'isOpen'),\n        highlightedIndex: getDefaultValue$1(props, 'highlightedIndex'),\n        selectedItem: props.items[action.index],\n        inputValue: props.itemToString(props.items[action.index])\n      };\n      break;\n\n    case InputKeyDownArrowDown:\n      if (state.isOpen) {\n        changes = {\n          highlightedIndex: getNextWrappingIndex(shiftKey ? 5 : 1, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, props.circularNavigation)\n        };\n      } else {\n        changes = {\n          highlightedIndex: getHighlightedIndexOnOpen(props, state, 1, action.getItemNodeFromIndex),\n          isOpen: props.items.length >= 0\n        };\n      }\n\n      break;\n\n    case InputKeyDownArrowUp:\n      if (state.isOpen) {\n        changes = {\n          highlightedIndex: getNextWrappingIndex(shiftKey ? -5 : -1, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, props.circularNavigation)\n        };\n      } else {\n        changes = {\n          highlightedIndex: getHighlightedIndexOnOpen(props, state, -1, action.getItemNodeFromIndex),\n          isOpen: props.items.length >= 0\n        };\n      }\n\n      break;\n\n    case InputKeyDownEnter:\n      changes = { ...(state.isOpen && state.highlightedIndex >= 0 && {\n          selectedItem: props.items[state.highlightedIndex],\n          isOpen: getDefaultValue$1(props, 'isOpen'),\n          highlightedIndex: getDefaultValue$1(props, 'highlightedIndex'),\n          inputValue: props.itemToString(props.items[state.highlightedIndex])\n        })\n      };\n      break;\n\n    case InputKeyDownEscape:\n      changes = {\n        isOpen: false,\n        highlightedIndex: -1,\n        ...(!state.isOpen && {\n          selectedItem: null,\n          inputValue: ''\n        })\n      };\n      break;\n\n    case InputKeyDownHome:\n      changes = {\n        highlightedIndex: getNextNonDisabledIndex(1, 0, props.items.length, action.getItemNodeFromIndex, false)\n      };\n      break;\n\n    case InputKeyDownEnd:\n      changes = {\n        highlightedIndex: getNextNonDisabledIndex(-1, props.items.length - 1, props.items.length, action.getItemNodeFromIndex, false)\n      };\n      break;\n\n    case InputBlur:\n      changes = {\n        isOpen: false,\n        highlightedIndex: -1,\n        ...(state.highlightedIndex >= 0 && action.selectItem && {\n          selectedItem: props.items[state.highlightedIndex],\n          inputValue: props.itemToString(props.items[state.highlightedIndex])\n        })\n      };\n      break;\n\n    case InputChange:\n      changes = {\n        isOpen: true,\n        highlightedIndex: getDefaultValue$1(props, 'highlightedIndex'),\n        inputValue: action.inputValue\n      };\n      break;\n\n    case FunctionSelectItem:\n      changes = {\n        selectedItem: action.selectedItem,\n        inputValue: props.itemToString(action.selectedItem)\n      };\n      break;\n\n    case ControlledPropUpdatedSelectedItem:\n      changes = {\n        inputValue: action.inputValue\n      };\n      break;\n\n    default:\n      return downshiftCommonReducer(state, action, stateChangeTypes$1);\n  }\n\n  return { ...state,\n    ...changes\n  };\n}\n/* eslint-enable complexity */\n\n/* eslint-disable max-statements */\nuseCombobox.stateChangeTypes = stateChangeTypes$1;\n\nfunction useCombobox(userProps) {\n  if (userProps === void 0) {\n    userProps = {};\n  }\n\n  validatePropTypes$1(userProps, useCombobox); // Props defaults and destructuring.\n\n  const props = { ...defaultProps$1,\n    ...userProps\n  };\n  const {\n    initialIsOpen,\n    defaultIsOpen,\n    items,\n    scrollIntoView,\n    environment,\n    getA11yStatusMessage,\n    getA11ySelectionMessage,\n    itemToString\n  } = props; // Initial state depending on controlled props.\n\n  const initialState = getInitialState$1(props);\n  const [state, dispatch] = useControlledReducer(downshiftUseComboboxReducer, initialState, props);\n  const {\n    isOpen,\n    highlightedIndex,\n    selectedItem,\n    inputValue\n  } = state; // Element refs.\n\n  const menuRef = useRef(null);\n  const itemRefs = useRef({});\n  const inputRef = useRef(null);\n  const toggleButtonRef = useRef(null);\n  const comboboxRef = useRef(null);\n  const isInitialMountRef = useRef(true); // prevent id re-generation between renders.\n\n  const elementIds = useElementIds(props); // used to keep track of how many items we had on previous cycle.\n\n  const previousResultCountRef = useRef(); // utility callback to get item element.\n\n  const latest = useLatestRef({\n    state,\n    props\n  });\n  const getItemNodeFromIndex = useCallback(index => itemRefs.current[elementIds.getItemId(index)], [elementIds]); // Effects.\n  // Sets a11y status message on changes in state.\n\n  useA11yMessageSetter(getA11yStatusMessage, [isOpen, highlightedIndex, inputValue, items], {\n    isInitialMount: isInitialMountRef.current,\n    previousResultCount: previousResultCountRef.current,\n    items,\n    environment,\n    itemToString,\n    ...state\n  }); // Sets a11y status message on changes in selectedItem.\n\n  useA11yMessageSetter(getA11ySelectionMessage, [selectedItem], {\n    isInitialMount: isInitialMountRef.current,\n    previousResultCount: previousResultCountRef.current,\n    items,\n    environment,\n    itemToString,\n    ...state\n  }); // Scroll on highlighted item if change comes from keyboard.\n\n  const shouldScrollRef = useScrollIntoView({\n    menuElement: menuRef.current,\n    highlightedIndex,\n    isOpen,\n    itemRefs,\n    scrollIntoView,\n    getItemNodeFromIndex\n  });\n  useControlPropsValidator({\n    isInitialMount: isInitialMountRef.current,\n    props,\n    state\n  }); // Focus the input on first render if required.\n\n  useEffect(() => {\n    const focusOnOpen = initialIsOpen || defaultIsOpen || isOpen;\n\n    if (focusOnOpen && inputRef.current) {\n      inputRef.current.focus();\n    } // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, []);\n  useEffect(() => {\n    if (isInitialMountRef.current) {\n      return;\n    }\n\n    previousResultCountRef.current = items.length;\n  }); // Add mouse/touch events to document.\n\n  const mouseAndTouchTrackersRef = useMouseAndTouchTracker(isOpen, [comboboxRef, menuRef, toggleButtonRef], environment, () => {\n    dispatch({\n      type: InputBlur,\n      selectItem: false\n    });\n  });\n  const setGetterPropCallInfo = useGetterPropsCalledChecker('getInputProps', 'getComboboxProps', 'getMenuProps'); // Make initial ref false.\n\n  useEffect(() => {\n    isInitialMountRef.current = false;\n  }, []); // Reset itemRefs on close.\n\n  useEffect(() => {\n    if (!isOpen) {\n      itemRefs.current = {};\n    }\n  }, [isOpen]);\n  /* Event handler functions */\n\n  const inputKeyDownHandlers = useMemo(() => ({\n    ArrowDown(event) {\n      event.preventDefault();\n      dispatch({\n        type: InputKeyDownArrowDown,\n        shiftKey: event.shiftKey,\n        getItemNodeFromIndex\n      });\n    },\n\n    ArrowUp(event) {\n      event.preventDefault();\n      dispatch({\n        type: InputKeyDownArrowUp,\n        shiftKey: event.shiftKey,\n        getItemNodeFromIndex\n      });\n    },\n\n    Home(event) {\n      if (!latest.current.state.isOpen) {\n        return;\n      }\n\n      event.preventDefault();\n      dispatch({\n        type: InputKeyDownHome,\n        getItemNodeFromIndex\n      });\n    },\n\n    End(event) {\n      if (!latest.current.state.isOpen) {\n        return;\n      }\n\n      event.preventDefault();\n      dispatch({\n        type: InputKeyDownEnd,\n        getItemNodeFromIndex\n      });\n    },\n\n    Escape(event) {\n      const latestState = latest.current.state;\n\n      if (latestState.isOpen || latestState.inputValue || latestState.selectedItem || latestState.highlightedIndex > -1) {\n        event.preventDefault();\n        dispatch({\n          type: InputKeyDownEscape\n        });\n      }\n    },\n\n    Enter(event) {\n      const latestState = latest.current.state; // if closed or no highlighted index, do nothing.\n\n      if (!latestState.isOpen || latestState.highlightedIndex < 0 || event.which === 229 // if IME composing, wait for next Enter keydown event.\n      ) {\n        return;\n      }\n\n      event.preventDefault();\n      dispatch({\n        type: InputKeyDownEnter,\n        getItemNodeFromIndex\n      });\n    }\n\n  }), [dispatch, latest, getItemNodeFromIndex]); // Getter props.\n\n  const getLabelProps = useCallback(labelProps => ({\n    id: elementIds.labelId,\n    htmlFor: elementIds.inputId,\n    ...labelProps\n  }), [elementIds]);\n  const getMenuProps = useCallback(function (_temp, _temp2) {\n    let {\n      onMouseLeave,\n      refKey = 'ref',\n      ref,\n      ...rest\n    } = _temp === void 0 ? {} : _temp;\n    let {\n      suppressRefError = false\n    } = _temp2 === void 0 ? {} : _temp2;\n    setGetterPropCallInfo('getMenuProps', suppressRefError, refKey, menuRef);\n    return {\n      [refKey]: handleRefs(ref, menuNode => {\n        menuRef.current = menuNode;\n      }),\n      id: elementIds.menuId,\n      role: 'listbox',\n      'aria-labelledby': elementIds.labelId,\n      onMouseLeave: callAllEventHandlers(onMouseLeave, () => {\n        dispatch({\n          type: MenuMouseLeave\n        });\n      }),\n      ...rest\n    };\n  }, [dispatch, setGetterPropCallInfo, elementIds]);\n  const getItemProps = useCallback(function (_temp3) {\n    let {\n      item,\n      index,\n      refKey = 'ref',\n      ref,\n      onMouseMove,\n      onMouseDown,\n      onClick,\n      onPress,\n      disabled,\n      ...rest\n    } = _temp3 === void 0 ? {} : _temp3;\n    const {\n      props: latestProps,\n      state: latestState\n    } = latest.current;\n    const itemIndex = getItemIndex(index, item, latestProps.items);\n\n    if (itemIndex < 0) {\n      throw new Error('Pass either item or item index in getItemProps!');\n    }\n\n    const onSelectKey = 'onClick';\n    const customClickHandler = onClick;\n\n    const itemHandleMouseMove = () => {\n      if (index === latestState.highlightedIndex) {\n        return;\n      }\n\n      shouldScrollRef.current = false;\n      dispatch({\n        type: ItemMouseMove,\n        index,\n        disabled\n      });\n    };\n\n    const itemHandleClick = () => {\n      dispatch({\n        type: ItemClick,\n        index\n      });\n    };\n\n    const itemHandleMouseDown = e => e.preventDefault();\n\n    return {\n      [refKey]: handleRefs(ref, itemNode => {\n        if (itemNode) {\n          itemRefs.current[elementIds.getItemId(itemIndex)] = itemNode;\n        }\n      }),\n      disabled,\n      role: 'option',\n      'aria-selected': `${itemIndex === latestState.highlightedIndex}`,\n      id: elementIds.getItemId(itemIndex),\n      ...(!disabled && {\n        [onSelectKey]: callAllEventHandlers(customClickHandler, itemHandleClick)\n      }),\n      onMouseMove: callAllEventHandlers(onMouseMove, itemHandleMouseMove),\n      onMouseDown: callAllEventHandlers(onMouseDown, itemHandleMouseDown),\n      ...rest\n    };\n  }, [dispatch, latest, shouldScrollRef, elementIds]);\n  const getToggleButtonProps = useCallback(function (_temp4) {\n    let {\n      onClick,\n      onPress,\n      refKey = 'ref',\n      ref,\n      ...rest\n    } = _temp4 === void 0 ? {} : _temp4;\n\n    const toggleButtonHandleClick = () => {\n      dispatch({\n        type: ToggleButtonClick\n      });\n\n      if (!latest.current.state.isOpen && inputRef.current) {\n        inputRef.current.focus();\n      }\n    };\n\n    return {\n      [refKey]: handleRefs(ref, toggleButtonNode => {\n        toggleButtonRef.current = toggleButtonNode;\n      }),\n      id: elementIds.toggleButtonId,\n      tabIndex: -1,\n      ...(!rest.disabled && { ...({\n          onClick: callAllEventHandlers(onClick, toggleButtonHandleClick)\n        })\n      }),\n      ...rest\n    };\n  }, [dispatch, latest, elementIds]);\n  const getInputProps = useCallback(function (_temp5, _temp6) {\n    let {\n      onKeyDown,\n      onChange,\n      onInput,\n      onBlur,\n      onChangeText,\n      refKey = 'ref',\n      ref,\n      ...rest\n    } = _temp5 === void 0 ? {} : _temp5;\n    let {\n      suppressRefError = false\n    } = _temp6 === void 0 ? {} : _temp6;\n    setGetterPropCallInfo('getInputProps', suppressRefError, refKey, inputRef);\n    const latestState = latest.current.state;\n\n    const inputHandleKeyDown = event => {\n      const key = normalizeArrowKey(event);\n\n      if (key && inputKeyDownHandlers[key]) {\n        inputKeyDownHandlers[key](event);\n      }\n    };\n\n    const inputHandleChange = event => {\n      dispatch({\n        type: InputChange,\n        inputValue: event.target.value\n      });\n    };\n\n    const inputHandleBlur = () => {\n      /* istanbul ignore else */\n      if (latestState.isOpen && !mouseAndTouchTrackersRef.current.isMouseDown) {\n        dispatch({\n          type: InputBlur,\n          selectItem: true\n        });\n      }\n    };\n    /* istanbul ignore next (preact) */\n\n\n    const onChangeKey = 'onChange';\n    let eventHandlers = {};\n\n    if (!rest.disabled) {\n      eventHandlers = {\n        [onChangeKey]: callAllEventHandlers(onChange, onInput, inputHandleChange),\n        onKeyDown: callAllEventHandlers(onKeyDown, inputHandleKeyDown),\n        onBlur: callAllEventHandlers(onBlur, inputHandleBlur)\n      };\n    }\n\n    return {\n      [refKey]: handleRefs(ref, inputNode => {\n        inputRef.current = inputNode;\n      }),\n      id: elementIds.inputId,\n      'aria-autocomplete': 'list',\n      'aria-controls': elementIds.menuId,\n      ...(latestState.isOpen && latestState.highlightedIndex > -1 && {\n        'aria-activedescendant': elementIds.getItemId(latestState.highlightedIndex)\n      }),\n      'aria-labelledby': elementIds.labelId,\n      // https://developer.mozilla.org/en-US/docs/Web/Security/Securing_your_site/Turning_off_form_autocompletion\n      // revert back since autocomplete=\"nope\" is ignored on latest Chrome and Opera\n      autoComplete: 'off',\n      value: latestState.inputValue,\n      ...eventHandlers,\n      ...rest\n    };\n  }, [dispatch, inputKeyDownHandlers, latest, mouseAndTouchTrackersRef, setGetterPropCallInfo, elementIds]);\n  const getComboboxProps = useCallback(function (_temp7, _temp8) {\n    let {\n      refKey = 'ref',\n      ref,\n      ...rest\n    } = _temp7 === void 0 ? {} : _temp7;\n    let {\n      suppressRefError = false\n    } = _temp8 === void 0 ? {} : _temp8;\n    setGetterPropCallInfo('getComboboxProps', suppressRefError, refKey, comboboxRef);\n    return {\n      [refKey]: handleRefs(ref, comboboxNode => {\n        comboboxRef.current = comboboxNode;\n      }),\n      role: 'combobox',\n      'aria-haspopup': 'listbox',\n      'aria-owns': elementIds.menuId,\n      'aria-expanded': latest.current.state.isOpen,\n      ...rest\n    };\n  }, [latest, setGetterPropCallInfo, elementIds]); // returns\n\n  const toggleMenu = useCallback(() => {\n    dispatch({\n      type: FunctionToggleMenu\n    });\n  }, [dispatch]);\n  const closeMenu = useCallback(() => {\n    dispatch({\n      type: FunctionCloseMenu\n    });\n  }, [dispatch]);\n  const openMenu = useCallback(() => {\n    dispatch({\n      type: FunctionOpenMenu\n    });\n  }, [dispatch]);\n  const setHighlightedIndex = useCallback(newHighlightedIndex => {\n    dispatch({\n      type: FunctionSetHighlightedIndex,\n      highlightedIndex: newHighlightedIndex\n    });\n  }, [dispatch]);\n  const selectItem = useCallback(newSelectedItem => {\n    dispatch({\n      type: FunctionSelectItem,\n      selectedItem: newSelectedItem\n    });\n  }, [dispatch]);\n  const setInputValue = useCallback(newInputValue => {\n    dispatch({\n      type: FunctionSetInputValue,\n      inputValue: newInputValue\n    });\n  }, [dispatch]);\n  const reset = useCallback(() => {\n    dispatch({\n      type: FunctionReset$1\n    });\n  }, [dispatch]);\n  return {\n    // prop getters.\n    getItemProps,\n    getLabelProps,\n    getMenuProps,\n    getInputProps,\n    getComboboxProps,\n    getToggleButtonProps,\n    // actions.\n    toggleMenu,\n    openMenu,\n    closeMenu,\n    setHighlightedIndex,\n    setInputValue,\n    selectItem,\n    reset,\n    // state.\n    highlightedIndex,\n    isOpen,\n    selectedItem,\n    inputValue\n  };\n}\n\nconst defaultStateValues = {\n  activeIndex: -1,\n  selectedItems: []\n};\n/**\n * Returns the initial value for a state key in the following order:\n * 1. controlled prop, 2. initial prop, 3. default prop, 4. default\n * value from Downshift.\n *\n * @param {Object} props Props passed to the hook.\n * @param {string} propKey Props key to generate the value for.\n * @returns {any} The initial value for that prop.\n */\n\nfunction getInitialValue(props, propKey) {\n  return getInitialValue$1(props, propKey, defaultStateValues);\n}\n/**\n * Returns the default value for a state key in the following order:\n * 1. controlled prop, 2. default prop, 3. default value from Downshift.\n *\n * @param {Object} props Props passed to the hook.\n * @param {string} propKey Props key to generate the value for.\n * @returns {any} The initial value for that prop.\n */\n\n\nfunction getDefaultValue(props, propKey) {\n  return getDefaultValue$1(props, propKey, defaultStateValues);\n}\n/**\n * Gets the initial state based on the provided props. It uses initial, default\n * and controlled props related to state in order to compute the initial value.\n *\n * @param {Object} props Props passed to the hook.\n * @returns {Object} The initial state.\n */\n\n\nfunction getInitialState(props) {\n  const activeIndex = getInitialValue(props, 'activeIndex');\n  const selectedItems = getInitialValue(props, 'selectedItems');\n  return {\n    activeIndex,\n    selectedItems\n  };\n}\n/**\n * Returns true if dropdown keydown operation is permitted. Should not be\n * allowed on keydown with modifier keys (ctrl, alt, shift, meta), on\n * input element with text content that is either highlighted or selection\n * cursor is not at the starting position.\n *\n * @param {KeyboardEvent} event The event from keydown.\n * @returns {boolean} Whether the operation is allowed.\n */\n\n\nfunction isKeyDownOperationPermitted(event) {\n  if (event.shiftKey || event.metaKey || event.ctrlKey || event.altKey) {\n    return false;\n  }\n\n  const element = event.target;\n\n  if (element instanceof HTMLInputElement && // if element is a text input\n  element.value !== '' && ( // and we have text in it\n  // and cursor is either not at the start or is currently highlighting text.\n  element.selectionStart !== 0 || element.selectionEnd !== 0)) {\n    return false;\n  }\n\n  return true;\n}\n/**\n * Returns a message to be added to aria-live region when item is removed.\n *\n * @param {Object} selectionParameters Parameters required to build the message.\n * @returns {string} The a11y message.\n */\n\n\nfunction getA11yRemovalMessage(selectionParameters) {\n  const {\n    removedSelectedItem,\n    itemToString: itemToStringLocal\n  } = selectionParameters;\n  return `${itemToStringLocal(removedSelectedItem)} has been removed.`;\n}\n\nconst propTypes = {\n  selectedItems: PropTypes.array,\n  initialSelectedItems: PropTypes.array,\n  defaultSelectedItems: PropTypes.array,\n  itemToString: PropTypes.func,\n  getA11yRemovalMessage: PropTypes.func,\n  stateReducer: PropTypes.func,\n  activeIndex: PropTypes.number,\n  initialActiveIndex: PropTypes.number,\n  defaultActiveIndex: PropTypes.number,\n  onActiveIndexChange: PropTypes.func,\n  onSelectedItemsChange: PropTypes.func,\n  keyNavigationNext: PropTypes.string,\n  keyNavigationPrevious: PropTypes.string,\n  environment: PropTypes.shape({\n    addEventListener: PropTypes.func,\n    removeEventListener: PropTypes.func,\n    document: PropTypes.shape({\n      getElementById: PropTypes.func,\n      activeElement: PropTypes.any,\n      body: PropTypes.any\n    })\n  })\n};\nconst defaultProps = {\n  itemToString: defaultProps$3.itemToString,\n  stateReducer: defaultProps$3.stateReducer,\n  environment: defaultProps$3.environment,\n  getA11yRemovalMessage,\n  keyNavigationNext: 'ArrowRight',\n  keyNavigationPrevious: 'ArrowLeft'\n}; // eslint-disable-next-line import/no-mutable-exports\n\nlet validatePropTypes = noop;\n/* istanbul ignore next */\n\nif (process.env.NODE_ENV !== 'production') {\n  validatePropTypes = (options, caller) => {\n    PropTypes.checkPropTypes(propTypes, options, 'prop', caller.name);\n  };\n}\n\nconst SelectedItemClick = process.env.NODE_ENV !== \"production\" ? '__selected_item_click__' : 0;\nconst SelectedItemKeyDownDelete = process.env.NODE_ENV !== \"production\" ? '__selected_item_keydown_delete__' : 1;\nconst SelectedItemKeyDownBackspace = process.env.NODE_ENV !== \"production\" ? '__selected_item_keydown_backspace__' : 2;\nconst SelectedItemKeyDownNavigationNext = process.env.NODE_ENV !== \"production\" ? '__selected_item_keydown_navigation_next__' : 3;\nconst SelectedItemKeyDownNavigationPrevious = process.env.NODE_ENV !== \"production\" ? '__selected_item_keydown_navigation_previous__' : 4;\nconst DropdownKeyDownNavigationPrevious = process.env.NODE_ENV !== \"production\" ? '__dropdown_keydown_navigation_previous__' : 5;\nconst DropdownKeyDownBackspace = process.env.NODE_ENV !== \"production\" ? '__dropdown_keydown_backspace__' : 6;\nconst DropdownClick = process.env.NODE_ENV !== \"production\" ? '__dropdown_click__' : 7;\nconst FunctionAddSelectedItem = process.env.NODE_ENV !== \"production\" ? '__function_add_selected_item__' : 8;\nconst FunctionRemoveSelectedItem = process.env.NODE_ENV !== \"production\" ? '__function_remove_selected_item__' : 9;\nconst FunctionSetSelectedItems = process.env.NODE_ENV !== \"production\" ? '__function_set_selected_items__' : 10;\nconst FunctionSetActiveIndex = process.env.NODE_ENV !== \"production\" ? '__function_set_active_index__' : 11;\nconst FunctionReset = process.env.NODE_ENV !== \"production\" ? '__function_reset__' : 12;\n\nvar stateChangeTypes = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  SelectedItemClick: SelectedItemClick,\n  SelectedItemKeyDownDelete: SelectedItemKeyDownDelete,\n  SelectedItemKeyDownBackspace: SelectedItemKeyDownBackspace,\n  SelectedItemKeyDownNavigationNext: SelectedItemKeyDownNavigationNext,\n  SelectedItemKeyDownNavigationPrevious: SelectedItemKeyDownNavigationPrevious,\n  DropdownKeyDownNavigationPrevious: DropdownKeyDownNavigationPrevious,\n  DropdownKeyDownBackspace: DropdownKeyDownBackspace,\n  DropdownClick: DropdownClick,\n  FunctionAddSelectedItem: FunctionAddSelectedItem,\n  FunctionRemoveSelectedItem: FunctionRemoveSelectedItem,\n  FunctionSetSelectedItems: FunctionSetSelectedItems,\n  FunctionSetActiveIndex: FunctionSetActiveIndex,\n  FunctionReset: FunctionReset\n});\n\n/* eslint-disable complexity */\n\nfunction downshiftMultipleSelectionReducer(state, action) {\n  const {\n    type,\n    index,\n    props,\n    selectedItem\n  } = action;\n  const {\n    activeIndex,\n    selectedItems\n  } = state;\n  let changes;\n\n  switch (type) {\n    case SelectedItemClick:\n      changes = {\n        activeIndex: index\n      };\n      break;\n\n    case SelectedItemKeyDownNavigationPrevious:\n      changes = {\n        activeIndex: activeIndex - 1 < 0 ? 0 : activeIndex - 1\n      };\n      break;\n\n    case SelectedItemKeyDownNavigationNext:\n      changes = {\n        activeIndex: activeIndex + 1 >= selectedItems.length ? -1 : activeIndex + 1\n      };\n      break;\n\n    case SelectedItemKeyDownBackspace:\n    case SelectedItemKeyDownDelete:\n      {\n        let newActiveIndex = activeIndex;\n\n        if (selectedItems.length === 1) {\n          newActiveIndex = -1;\n        } else if (activeIndex === selectedItems.length - 1) {\n          newActiveIndex = selectedItems.length - 2;\n        }\n\n        changes = {\n          selectedItems: [...selectedItems.slice(0, activeIndex), ...selectedItems.slice(activeIndex + 1)],\n          ...{\n            activeIndex: newActiveIndex\n          }\n        };\n        break;\n      }\n\n    case DropdownKeyDownNavigationPrevious:\n      changes = {\n        activeIndex: selectedItems.length - 1\n      };\n      break;\n\n    case DropdownKeyDownBackspace:\n      changes = {\n        selectedItems: selectedItems.slice(0, selectedItems.length - 1)\n      };\n      break;\n\n    case FunctionAddSelectedItem:\n      changes = {\n        selectedItems: [...selectedItems, selectedItem]\n      };\n      break;\n\n    case DropdownClick:\n      changes = {\n        activeIndex: -1\n      };\n      break;\n\n    case FunctionRemoveSelectedItem:\n      {\n        let newActiveIndex = activeIndex;\n        const selectedItemIndex = selectedItems.indexOf(selectedItem);\n\n        if (selectedItemIndex >= 0) {\n          if (selectedItems.length === 1) {\n            newActiveIndex = -1;\n          } else if (selectedItemIndex === selectedItems.length - 1) {\n            newActiveIndex = selectedItems.length - 2;\n          }\n\n          changes = {\n            selectedItems: [...selectedItems.slice(0, selectedItemIndex), ...selectedItems.slice(selectedItemIndex + 1)],\n            activeIndex: newActiveIndex\n          };\n        }\n\n        break;\n      }\n\n    case FunctionSetSelectedItems:\n      {\n        const {\n          selectedItems: newSelectedItems\n        } = action;\n        changes = {\n          selectedItems: newSelectedItems\n        };\n        break;\n      }\n\n    case FunctionSetActiveIndex:\n      {\n        const {\n          activeIndex: newActiveIndex\n        } = action;\n        changes = {\n          activeIndex: newActiveIndex\n        };\n        break;\n      }\n\n    case FunctionReset:\n      changes = {\n        activeIndex: getDefaultValue(props, 'activeIndex'),\n        selectedItems: getDefaultValue(props, 'selectedItems')\n      };\n      break;\n\n    default:\n      throw new Error('Reducer called without proper action type.');\n  }\n\n  return { ...state,\n    ...changes\n  };\n}\n\nuseMultipleSelection.stateChangeTypes = stateChangeTypes;\n\nfunction useMultipleSelection(userProps) {\n  if (userProps === void 0) {\n    userProps = {};\n  }\n\n  validatePropTypes(userProps, useMultipleSelection); // Props defaults and destructuring.\n\n  const props = { ...defaultProps,\n    ...userProps\n  };\n  const {\n    getA11yRemovalMessage,\n    itemToString,\n    environment,\n    keyNavigationNext,\n    keyNavigationPrevious\n  } = props; // Reducer init.\n\n  const [state, dispatch] = useControlledReducer$1(downshiftMultipleSelectionReducer, getInitialState(props), props);\n  const {\n    activeIndex,\n    selectedItems\n  } = state; // Refs.\n\n  const isInitialMountRef = useRef(true);\n  const dropdownRef = useRef(null);\n  const previousSelectedItemsRef = useRef(selectedItems);\n  const selectedItemRefs = useRef();\n  selectedItemRefs.current = [];\n  const latest = useLatestRef({\n    state,\n    props\n  }); // Effects.\n\n  /* Sets a11y status message on changes in selectedItem. */\n\n  useEffect(() => {\n    if (isInitialMountRef.current) {\n      return;\n    }\n\n    if (selectedItems.length < previousSelectedItemsRef.current.length) {\n      const removedSelectedItem = previousSelectedItemsRef.current.find(item => selectedItems.indexOf(item) < 0);\n      setStatus(getA11yRemovalMessage({\n        itemToString,\n        resultCount: selectedItems.length,\n        removedSelectedItem,\n        activeIndex,\n        activeSelectedItem: selectedItems[activeIndex]\n      }), environment.document);\n    }\n\n    previousSelectedItemsRef.current = selectedItems; // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [selectedItems.length]); // Sets focus on active item.\n\n  useEffect(() => {\n    if (isInitialMountRef.current) {\n      return;\n    }\n\n    if (activeIndex === -1 && dropdownRef.current) {\n      dropdownRef.current.focus();\n    } else if (selectedItemRefs.current[activeIndex]) {\n      selectedItemRefs.current[activeIndex].focus();\n    }\n  }, [activeIndex]);\n  useControlPropsValidator({\n    isInitialMount: isInitialMountRef.current,\n    props,\n    state\n  });\n  const setGetterPropCallInfo = useGetterPropsCalledChecker('getDropdownProps'); // Make initial ref false.\n\n  useEffect(() => {\n    isInitialMountRef.current = false;\n  }, []); // Event handler functions.\n\n  const selectedItemKeyDownHandlers = useMemo(() => ({\n    [keyNavigationPrevious]() {\n      dispatch({\n        type: SelectedItemKeyDownNavigationPrevious\n      });\n    },\n\n    [keyNavigationNext]() {\n      dispatch({\n        type: SelectedItemKeyDownNavigationNext\n      });\n    },\n\n    Delete() {\n      dispatch({\n        type: SelectedItemKeyDownDelete\n      });\n    },\n\n    Backspace() {\n      dispatch({\n        type: SelectedItemKeyDownBackspace\n      });\n    }\n\n  }), [dispatch, keyNavigationNext, keyNavigationPrevious]);\n  const dropdownKeyDownHandlers = useMemo(() => ({\n    [keyNavigationPrevious](event) {\n      if (isKeyDownOperationPermitted(event)) {\n        dispatch({\n          type: DropdownKeyDownNavigationPrevious\n        });\n      }\n    },\n\n    Backspace(event) {\n      if (isKeyDownOperationPermitted(event)) {\n        dispatch({\n          type: DropdownKeyDownBackspace\n        });\n      }\n    }\n\n  }), [dispatch, keyNavigationPrevious]); // Getter props.\n\n  const getSelectedItemProps = useCallback(function (_temp) {\n    let {\n      refKey = 'ref',\n      ref,\n      onClick,\n      onKeyDown,\n      selectedItem,\n      index,\n      ...rest\n    } = _temp === void 0 ? {} : _temp;\n    const {\n      state: latestState\n    } = latest.current;\n    const itemIndex = getItemIndex(index, selectedItem, latestState.selectedItems);\n\n    if (itemIndex < 0) {\n      throw new Error('Pass either selectedItem or index in getSelectedItemProps!');\n    }\n\n    const selectedItemHandleClick = () => {\n      dispatch({\n        type: SelectedItemClick,\n        index\n      });\n    };\n\n    const selectedItemHandleKeyDown = event => {\n      const key = normalizeArrowKey(event);\n\n      if (key && selectedItemKeyDownHandlers[key]) {\n        selectedItemKeyDownHandlers[key](event);\n      }\n    };\n\n    return {\n      [refKey]: handleRefs(ref, selectedItemNode => {\n        if (selectedItemNode) {\n          selectedItemRefs.current.push(selectedItemNode);\n        }\n      }),\n      tabIndex: index === latestState.activeIndex ? 0 : -1,\n      onClick: callAllEventHandlers(onClick, selectedItemHandleClick),\n      onKeyDown: callAllEventHandlers(onKeyDown, selectedItemHandleKeyDown),\n      ...rest\n    };\n  }, [dispatch, latest, selectedItemKeyDownHandlers]);\n  const getDropdownProps = useCallback(function (_temp2, _temp3) {\n    let {\n      refKey = 'ref',\n      ref,\n      onKeyDown,\n      onClick,\n      preventKeyAction = false,\n      ...rest\n    } = _temp2 === void 0 ? {} : _temp2;\n    let {\n      suppressRefError = false\n    } = _temp3 === void 0 ? {} : _temp3;\n    setGetterPropCallInfo('getDropdownProps', suppressRefError, refKey, dropdownRef);\n\n    const dropdownHandleKeyDown = event => {\n      const key = normalizeArrowKey(event);\n\n      if (key && dropdownKeyDownHandlers[key]) {\n        dropdownKeyDownHandlers[key](event);\n      }\n    };\n\n    const dropdownHandleClick = () => {\n      dispatch({\n        type: DropdownClick\n      });\n    };\n\n    return {\n      [refKey]: handleRefs(ref, dropdownNode => {\n        if (dropdownNode) {\n          dropdownRef.current = dropdownNode;\n        }\n      }),\n      ...(!preventKeyAction && {\n        onKeyDown: callAllEventHandlers(onKeyDown, dropdownHandleKeyDown),\n        onClick: callAllEventHandlers(onClick, dropdownHandleClick)\n      }),\n      ...rest\n    };\n  }, [dispatch, dropdownKeyDownHandlers, setGetterPropCallInfo]); // returns\n\n  const addSelectedItem = useCallback(selectedItem => {\n    dispatch({\n      type: FunctionAddSelectedItem,\n      selectedItem\n    });\n  }, [dispatch]);\n  const removeSelectedItem = useCallback(selectedItem => {\n    dispatch({\n      type: FunctionRemoveSelectedItem,\n      selectedItem\n    });\n  }, [dispatch]);\n  const setSelectedItems = useCallback(newSelectedItems => {\n    dispatch({\n      type: FunctionSetSelectedItems,\n      selectedItems: newSelectedItems\n    });\n  }, [dispatch]);\n  const setActiveIndex = useCallback(newActiveIndex => {\n    dispatch({\n      type: FunctionSetActiveIndex,\n      activeIndex: newActiveIndex\n    });\n  }, [dispatch]);\n  const reset = useCallback(() => {\n    dispatch({\n      type: FunctionReset\n    });\n  }, [dispatch]);\n  return {\n    getSelectedItemProps,\n    getDropdownProps,\n    addSelectedItem,\n    removeSelectedItem,\n    setSelectedItems,\n    setActiveIndex,\n    reset,\n    selectedItems,\n    activeIndex\n  };\n}\n\nexport { Downshift$1 as default, resetIdCounter, useCombobox, useMultipleSelection, useSelect };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}